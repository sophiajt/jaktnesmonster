class APU {
    timer: u16,
    pulse1: Pulse,
    pulse2: Pulse,
    triangle: Triangle,
    noise: Noise,
    public buffer: [i16],

    public fn init() throws -> APU {
        return APU(timer: 0,
            pulse1: Pulse::init(),
            pulse2: Pulse::init(),
            triangle: Triangle::init(),
            noise: Noise::init(),
            buffer: [0i16; 44100 / 60])
    }

    public fn read_apu_addr(this, address: u16) -> u8 {
        return 0
    }

    public fn write_4008(mut this, value: u8) {
        .triangle.register1_write(value)
    }

    public fn write_400a(mut this, value: u8) {
        .triangle.register3_write(value)
    }

    public fn write_400b(mut this, value: u8) {
        .triangle.register4_write(value)
    }

    public fn write_apu_addr(mut this, address: u16, value: u8) {
        match address {
            //     0x4000 => .write_4000(value)
            0x4000 => .pulse1.register1_write(value)
            0x4001 => .pulse1.register2_write(value)
            0x4002 => .pulse1.register3_write(value)
            0x4003 => .pulse1.register4_write(value)
            0x4004 => .pulse2.register1_write(value)
            0x4005 => .pulse2.register2_write(value)
            0x4006 => .pulse2.register3_write(value)
            0x4007 => .pulse2.register4_write(value)
            // 0x4008 => .write_4008(value)
            // 0x400a => .write_400a(value)
            // 0x400b => .write_400b(value)
            //     0x400c => .noise.register1_write(value)
            //     0x400e => .noise.register3_write(value)
            //     0x400f => .noise.register4_write(value)
            else => {
            }
        }
    }

    public fn tick(mut this, cycles: u16) throws {
        // .pulse1.tick(cycles)
        // .pulse2.tick(cycles)
        // .triangle.tick(cycles)
        // .noise.tick(cycles)
    }

    public fn render(mut this) {
        mut i = 0
        .pulse1.render()
        .pulse2.render()

        // FIXME: rendering needs to use the PPU mixer
        while i < 44100 / 60 {
            .buffer[i] = .pulse1.buffer[i] +
            .pulse2.buffer[i]
            //  .triangle.buffer[i] + 
            //  .noise.buffer[i]
            ++i
        }
    }
}

struct Pulse {
    duty: u8
    envelope_loop: bool
    constant_volume: u8
    volume_envelope: u8
    sweep_enabled: bool
    sweep_period: u8
    sweep_negative: bool
    sweep_shift: u8
    timer: u64
    length_counter: u8
    phase: u64
    buffer: [i16]

    public fn init() throws -> Pulse {
        return Pulse(duty: 0,
            envelope_loop: false,
            constant_volume: 0,
            volume_envelope: 0,
            sweep_enabled: false,
            sweep_period: 0,
            sweep_negative: false,
            sweep_shift: 0,
            timer: 0,
            length_counter: 0,
            phase: 0,
            buffer: [0i16; 44100 / 60]
        )
    }

    public fn render(mut this) {
        if not .envelope_loop {
            if .length_counter == 0 {
                for i in 0..(.buffer.size()) {
                    .buffer[i] = 0
                }
                return
            } else {
                .length_counter--
            }
        }

        mut volume = 5000i16

        if .timer < 8 {
            if .volume_envelope > 0 {
                volume = volume / .volume_envelope as! i16 * (.volume_envelope as! i16 - 1)
                .volume_envelope -= 1
            } else {
                volume = 0
            }
        }

        if volume == 0  {
            for i in 0..(.buffer.size()) {
                .buffer[i] = 0
            }
        } else {
            let pitch = 1789773 / (16 * (.timer as! u64 + 1))
            let window_length = 44100 / 60u64
            let transition_length = 44100 / pitch
            mut sample = -volume

            let phase_end = .phase + window_length

            mut sound_position = .phase % transition_length

            for i in 0..window_length {
                let value = transition_length % 8
                if sound_position < (transition_length / 2) {
                    .buffer[i] = volume
                } else {
                    .buffer[i] = -volume
                }

                sound_position++
                if sound_position == transition_length {
                    sound_position = 0
                }
            }

            .phase = phase_end
            if .phase >= 44100 {
                .phase -= 44100
            }
        }
    }

    public fn register1_write(mut this, value: u8) {
        .duty = value >> 6
        .envelope_loop = ((value >> 5) & 0x1) == 0x1
        .constant_volume = (value >> 4) & 0x1
        .volume_envelope = value & 0b1111

        println(
            "register 1. duty: {}, env loop: {}, const vol: {}, vol env: {}"
            .duty
            .envelope_loop
            .constant_volume
            .volume_envelope
        )
    }

    public fn register2_write(mut this, value: u8) {
        .sweep_enabled = (value & 0b1000_0000) == 0b1000_0000
        .sweep_period = (value >> 4) & 0b111
        .sweep_negative = (value & 0b1000) == 0b1000
        .sweep_shift = value & 0b111

        println(
            "sweep: {}, period: {}, negative: {}, shift: {}"
            .sweep_enabled
            .sweep_period
            .sweep_negative
            .sweep_shift
        )
        // println("register 2 write: {:x} {}", value, this)
    }

    public fn register3_write(mut this, value: u8) {
        .timer = (.timer & 0xff00) | value

        println("register 3 write: timer: {}", .timer)
    }

    public fn register4_write(mut this, value: u8) {
        match (value >> 3) {
            0b11111 => { .length_counter = 30 }
            0b11110 => { .length_counter = 32 }
            0b11101 => { .length_counter = 28 }
            0b11100 => { .length_counter = 16 }
            0b11011 => { .length_counter = 26 }
            0b11010 => { .length_counter = 72 }
            0b11001 => { .length_counter = 24 }
            0b11000 => { .length_counter = 192 }
            0b10111 => { .length_counter = 22 }
            0b10110 => { .length_counter = 96 }
            0b10101 => { .length_counter = 20 }
            0b10100 => { .length_counter = 48 }
            0b10011 => { .length_counter = 18 }
            0b10010 => { .length_counter = 24 }
            0b10001 => { .length_counter = 16 }
            0b10000 => { .length_counter = 12 }
            0b1111 =>  { .length_counter = 14 }
            0b1110 =>  { .length_counter = 26 }
            0b1101 =>  { .length_counter = 12 }
            0b1100 =>  { .length_counter = 14 }
            0b1011 =>  { .length_counter = 10 }
            0b1010 =>  { .length_counter = 60 }
            0b1001 =>  { .length_counter = 8 }
            0b1000 =>  { .length_counter = 160 }
            0b111 =>   { .length_counter = 6 }
            0b110 =>   { .length_counter = 80 }
            0b101 =>   { .length_counter = 4 }
            0b100 =>   { .length_counter = 40 }
            0b11 =>    { .length_counter = 2 }
            0b10 =>    { .length_counter = 20 }
            0b1 =>     { .length_counter = 254 }
            else =>    { .length_counter = 10 }
        }
        .length_counter = (value >> 3) * 8

        .timer &= 0xff
        .timer |= (value as! u64 & 0x7) << 8

        println("register 4 write: length_counter: {} timer: {}", .length_counter, .timer)
        // println("register 4 write: {:x} {}", value, this)
    }

    public fn tick(mut this, cycles: u16) throws {
        // TODO: handle overflow
        // .timer += cycles

        // 11-bit timer rollover
        // if .timer > 0b111_1111_1111 {
        //     .timer -= 0b111_1111_1111
        // }
    }
}

struct Triangle {
    timer: u16
    length_counter: u8
    linear_counter: u8
    buffer: [i16]

    public fn init() throws -> Triangle {
        return Triangle(timer: 0,
            length_counter: 0,
            linear_counter: 0,
            buffer: [0i16; 44100 / 60])
    }

    public fn tick(mut this, cycles: u16) throws {
        // TODO: handle overflow
        .timer += cycles / 2
    }

    public fn register1_write(mut this, value: u8) {
        let control_flag = (value & 0b1000_0000) >> 7
        let counter_reload = value & 0b0111_1111

        // println("triangle:");
        // print("control flag: {:0>2x} ", control_flag)
        // println("counter reload: {:0>2x} ", control_flag)
    }

    public fn register3_write(mut this, value: u8) {
        // println("timer low: {:0>2x}", value)
    }

    public fn register4_write(mut this, value: u8) {
        let timer_high = (value & 0b111)
        // println("timer high: {:0>2x}", timer_high)
    }

}

struct Noise {
    timer: u16
    length_counter: u8
    envelope: u8
    linear_feedback_shift_register: u8
    buffer: [i16]

    public fn init() throws -> Noise {
        return Noise(timer: 0,
            length_counter: 0,
            envelope: 0,
            linear_feedback_shift_register: 0,
            buffer: [0i16; 44100 / 60])
    }

    public fn tick(mut this, cycles: u16) throws {
        // TODO: handle overflow
        // .timer += cycles
    }

    public fn register1_write(mut this, value: u8) {

    }

    public fn register3_write(mut this, value: u8) {

    }

    public fn register4_write(mut this, value: u8) {

    }

}