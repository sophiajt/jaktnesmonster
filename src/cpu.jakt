import system { System }

// Sign extend byte
function sxb(value: u8) -> u16 {
    mut value_16 = value as! u16;
    if (value > 0x7f) {
        value_16 |= 0xff00
    }
    return value_16
}

class CPU {
    // registers
    public a: u8
    public x: u8
    public y: u8
    public pc: u16
    public s: u8

    // flags
    public carry: bool
    public zero: bool
    public interrupt_disable: bool
    public decimal: bool
    public break_flag: bool
    public overflow: bool
    public negative: bool

    public system: System
    public clock: u64

    public function init(mut system: System) throws -> CPU {
        let reset_vector = system.read_word(address: 0xfffc)

        return CPU (
            a: 0
            x: 0
            y: 0
            pc: reset_vector
            s: 0xfd
            carry: false
            zero: false
            interrupt_disable: true
            decimal: false
            break_flag: false
            overflow: false
            negative: false
            system
            clock: 0
        )
    }

    public function run_opcode(mut this) {
        let opcode = .system.read_byte(address: .pc)
        match opcode {
            0x00 => .brk()
            0x01 => .ora(opcode)
            0x02 => .jam()
            0x03 => .slo(opcode)
            0x04 => .illegal_nop(opcode)
            0x05 => .ora(opcode)
            0x06 => .asl(opcode)
            0x07 => .slo(opcode)
            0x08 => .php()
            0x09 => .ora(opcode)
            0x0a => .asl(opcode)
            0x0b => .anc()
            0x0c => .illegal_nop(opcode)
            0x0d => .ora(opcode)
            0x0e => .asl(opcode)
            0x0f => .slo(opcode)
            0x10 => .bpl()
            0x11 => .ora(opcode)
            0x12 => .jam()
            0x13 => .slo(opcode)
            0x14 => .illegal_nop(opcode)
            0x15 => .ora(opcode)
            0x16 => .asl(opcode)
            0x17 => .slo(opcode)
            0x18 => .clc()
            0x19 => .ora(opcode)
            0x1a => .illegal_nop(opcode)
            0x1b => .slo(opcode)
            0x1c => .illegal_nop(opcode)
            0x1d => .ora(opcode)
            0x1e => .asl(opcode)
            0x1f => .slo(opcode)
            0x20 => .jsr()
            0x21 => .and_opcode(opcode)
            0x22 => .jam()
            0x23 => .rla(opcode)
            0x24 => .bit(opcode)
            0x25 => .and_opcode(opcode)
            0x26 => .rol(opcode)
            0x27 => .rla(opcode)
            0x28 => .plp()
            0x29 => .and_opcode(opcode)
            0x2a => .rol(opcode)
            0x2b => .anc()
            0x2c => .bit(opcode)
            0x2d => .and_opcode(opcode)
            0x2e => .rol(opcode)
            0x2f => .rla(opcode)
            0x30 => .bmi()
            0x31 => .and_opcode(opcode)
            0x32 => .jam()
            0x33 => .rla(opcode)
            0x34 => .illegal_nop(opcode)
            0x35 => .and_opcode(opcode)
            0x36 => .rol(opcode)
            0x37 => .rla(opcode)
            0x38 => .sec()
            0x39 => .and_opcode(opcode)
            0x3a => .illegal_nop(opcode)
            0x3b => .rla(opcode)
            0x3c => .illegal_nop(opcode)
            0x3d => .and_opcode(opcode)
            0x3e => .rol(opcode)
            0x3f => .rla(opcode)
            0x40 => .rti()
            0x41 => .eor(opcode)
            0x42 => .jam()
            0x43 => .sre(opcode)
            0x44 => .illegal_nop(opcode)
            0x45 => .eor(opcode)
            0x46 => .lsr(opcode)
            0x47 => .sre(opcode)
            0x48 => .pha()
            0x49 => .eor(opcode)
            0x4a => .lsr(opcode)
            0x4b => .alr()
            0x4c => .jmp(opcode)
            0x4d => .eor(opcode)
            0x4e => .lsr(opcode)
            0x4f => .sre(opcode)
            0x50 => .bvc()
            0x51 => .eor(opcode)
            0x52 => .jam()
            0x53 => .sre(opcode)
            0x54 => .illegal_nop(opcode)
            0x55 => .eor(opcode)
            0x56 => .lsr(opcode)
            0x57 => .sre(opcode)
            0x58 => .cli()
            0x59 => .eor(opcode)
            0x5a => .illegal_nop(opcode)
            0x5b => .sre(opcode)
            0x5c => .illegal_nop(opcode)
            0x5d => .eor(opcode)
            0x5e => .lsr(opcode)
            0x5f => .sre(opcode)
            0x60 => .rts()
            0x61 => .adc(opcode)
            0x62 => .jam()
            0x63 => .rra(opcode)
            0x64 => .illegal_nop(opcode)
            0x65 => .adc(opcode)
            0x66 => .ror(opcode)
            0x67 => .rra(opcode)
            0x68 => .pla()
            0x69 => .adc(opcode)
            0x6a => .ror(opcode)
            0x6b => .arr()
            0x6c => .jmp(opcode)
            0x6d => .adc(opcode)
            0x6e => .ror(opcode)
            0x6f => .rra(opcode)
            0x70 => .bvs()
            0x71 => .adc(opcode)
            0x72 => .jam()
            0x73 => .rra(opcode)
            0x74 => .illegal_nop(opcode)
            0x75 => .adc(opcode)
            0x76 => .ror(opcode)
            0x77 => .rra(opcode)
            0x78 => .sei()
            0x79 => .adc(opcode)
            0x7a => .illegal_nop(opcode)
            0x7b => .rra(opcode)
            0x7c => .illegal_nop(opcode)
            0x7d => .adc(opcode)
            0x7e => .ror(opcode)
            0x7f => .rra(opcode)
            0x80 => .illegal_nop(opcode)
            0x81 => .sta(opcode)
            0x82 => .illegal_nop(opcode)
            0x83 => .sax(opcode)
            0x84 => .sty(opcode)
            0x85 => .sta(opcode)
            0x86 => .stx(opcode)
            0x87 => .sax(opcode)
            0x88 => .dey()
            0x89 => .illegal_nop(opcode)
            0x8a => .txa()
            0x8b => .ane()
            0x8c => .sty(opcode)
            0x8d => .sta(opcode)
            0x8e => .stx(opcode)
            0x8f => .sax(opcode)
            0x90 => .bcc()
            0x91 => .sta(opcode)
            0x92 => .jam()
            0x93 => .sha(opcode)
            0x94 => .sty(opcode)
            0x95 => .sta(opcode)
            0x96 => .stx(opcode)
            0x97 => .sax(opcode)
            0x98 => .tya()
            0x99 => .sta(opcode)
            0x9a => .txs()
            0x9b => .tas()
            0x9c => .shy()
            0x9d => .sta(opcode)
            0x9e => .shx()
            0x9f => .sha(opcode)
            0xa0 => .ldy(opcode)
            0xa1 => .lda(opcode)
            0xa2 => .ldx(opcode)
            0xa3 => .lax(opcode)
            0xa4 => .ldy(opcode)
            0xa5 => .lda(opcode)
            0xa6 => .ldx(opcode)
            0xa7 => .lax(opcode)
            0xa8 => .tay()
            0xa9 => .lda(opcode)
            0xaa => .tax()
            0xab => .lxa()
            0xac => .ldy(opcode)
            0xad => .lda(opcode)
            0xae => .ldx(opcode)
            0xaf => .lax(opcode)
            0xb0 => .bcs()
            0xb1 => .lda(opcode)
            0xb2 => .jam()
            0xb3 => .lax(opcode)
            0xb4 => .ldy(opcode)
            0xb5 => .lda(opcode)
            0xb6 => .ldx(opcode)
            0xb7 => .lax(opcode)
            0xb8 => .clv()
            0xb9 => .lda(opcode)
            0xba => .tsx()
            0xbb => .las()
            0xbc => .ldy(opcode)
            0xbd => .lda(opcode)
            0xbe => .ldx(opcode)
            0xbf => .lax(opcode)
            0xc0 => .cpy(opcode)
            0xc1 => .cmp(opcode)
            0xc2 => .illegal_nop(opcode)
            0xc3 => .dcp(opcode)
            0xc4 => .cpy(opcode)
            0xc5 => .cmp(opcode)
            0xc6 => .dec(opcode)
            0xc7 => .dcp(opcode)
            0xc8 => .iny()
            0xc9 => .cmp(opcode)
            0xca => .dex()
            0xcb => .sbx()
            0xcc => .cpy(opcode)
            0xcd => .cmp(opcode)
            0xce => .dec(opcode)
            0xcf => .dcp(opcode)
            0xd0 => .bne()
            0xd1 => .cmp(opcode)
            0xd2 => .jam()
            0xd3 => .dcp(opcode)
            0xd4 => .illegal_nop(opcode)
            0xd5 => .cmp(opcode)
            0xd6 => .dec(opcode)
            0xd7 => .dcp(opcode)
            0xd8 => .cld()
            0xd9 => .cmp(opcode)
            0xda => .illegal_nop(opcode)
            0xdb => .dcp(opcode)
            0xdc => .illegal_nop(opcode)
            0xdd => .cmp(opcode)
            0xde => .dec(opcode)
            0xdf => .dcp(opcode)
            0xe0 => .cpx(opcode)
            0xe1 => .sbc(opcode)
            0xe2 => .illegal_nop(opcode)
            0xe3 => .isc(opcode)
            0xe4 => .cpx(opcode)
            0xe5 => .sbc(opcode)
            0xe6 => .inc(opcode)
            0xe7 => .isc(opcode)
            0xe8 => .inx()
            0xe9 => .sbc(opcode)
            0xea => .nop()
            0xeb => .usbc()
            0xec => .cpx(opcode)
            0xed => .sbc(opcode)
            0xee => .inc(opcode)
            0xef => .isc(opcode)
            0xf0 => .beq()
            0xf1 => .sbc(opcode)
            0xf2 => .jam()
            0xf3 => .isc(opcode)
            0xf4 => .illegal_nop(opcode)
            0xf5 => .sbc(opcode)
            0xf6 => .inc(opcode)
            0xf7 => .isc(opcode)
            0xf8 => .sed()
            0xf9 => .sbc(opcode)
            0xfa => .illegal_nop(opcode)
            0xfb => .isc(opcode)
            0xfc => .illegal_nop(opcode)
            0xfd => .sbc(opcode)
            0xfe => .inc(opcode)
            0xff => .isc(opcode)

            else => {
                eprintln("{:0>4x}: unknown opcode: {:0>2x}", .pc, opcode)
                .pc += 1
                .clock += 2
                abort()
            }
        }
    }

    // Interrupts
    public function nmi(mut this) {
        let nmi_vector = .system.read_word(address: 0xfffa)

        .clock += 7
        .push_word(value: .pc)
        .push_status()

        .pc = nmi_vector
    }

    // Addressing modes
    function immediate(mut this) -> u8 {
        let arg_address = .pc + 1
        return .system.read_byte(address: arg_address)
    }

    function zero_page(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = .system.read_byte(address: arg_address) as! u16
        return .system.read_byte(address)
    }

    function zero_page_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = .system.read_byte(address: arg_address) as! u16
        .system.write_byte(address, value)
    }

    function zero_page_x(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = unchecked_add<u8>(.system.read_byte(address: arg_address), .x) as! u16
        return .system.read_byte(address)
    }

    function zero_page_x_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = unchecked_add<u8>(.system.read_byte(address: arg_address), .x) as! u16
        .system.write_byte(address, value)
    }

    function zero_page_y(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = unchecked_add<u8>(.system.read_byte(address: arg_address), .y) as! u16
        return .system.read_byte(address)        
    }

    function zero_page_y_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = unchecked_add<u8>(.system.read_byte(address: arg_address), .y) as! u16
        .system.write_byte(address, value)
    }
    
    function indirect_zero_page_x(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = unchecked_add<u8>(.system.read_byte(address: arg_address), .x) as! u16
        let new_address = .system.read_word_wrapped(address)

        // 0xff, x (where x is 1)
        // reads: 00, 01 for the address

        return .system.read_byte(address: new_address)
    }

    function indirect_zero_page_x_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = unchecked_add<u8>(.system.read_byte(address: arg_address), .x) as! u16
        let new_address = .system.read_word_wrapped(address)

        .system.write_byte(address: new_address, value)
    }
    
    function indirect_zero_page_y(mut this, check_extra_clock: bool) -> u8 {
        let arg_address = .pc + 1
        let address = (.system.read_byte(address: arg_address)) as! u16

        let pre_index = .system.read_word_wrapped(address)
        let page = pre_index >> 8

        let new_address: u16 = unchecked_add<u16>(pre_index, .y as! u16)   
        let new_page = new_address >> 8

        // Example of crossing pages:
        // 01ff -> 0200
        if check_extra_clock and page != new_page {
            .clock += 1
        }

        return .system.read_byte(address: new_address)
    }

    function indirect_zero_page_y_set(mut this, value: u8){
        let arg_address = .pc + 1
        let address = (.system.read_byte(address: arg_address)) as! u16

        let pre_index = .system.read_word_wrapped(address)

        let new_address: u16 = unchecked_add<u16>(pre_index, .y as! u16)   

        .system.write_byte(address: new_address, value)
    }
    
    function absolute(mut this) -> u8 {
        let arg_address = .pc + 1
        let address = .system.read_word(address: arg_address)
        return .system.read_byte(address)
    }

    function absolute_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = .system.read_word(address: arg_address)
        .system.write_byte(address, value)
    }

    function absolute_x(mut this, check_extra_clock: bool) -> u8 {
        let arg_address = .pc + 1
        mut address = .system.read_word(address: arg_address)
        let page = address >> 8

        address = unchecked_add<u16>(.x as! u16, address)
        let new_page = address >> 8

        // Example of crossing pages:
        // 01ff -> 0200
        if check_extra_clock and page != new_page {
            .clock += 1
        }

        return .system.read_byte(address)
    }

    function absolute_x_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = .system.read_word(address: arg_address)

        .system.write_byte(address: unchecked_add<u16>(.x as! u16, address), value)
    }

    function absolute_y(mut this, check_extra_clock: bool) -> u8 {
        let arg_address = .pc + 1
        mut address = .system.read_word(address: arg_address)
        let page = address >> 8

        address = unchecked_add<u16>(.y as! u16, address)
        let new_page = address >> 8

        // Example of crossing pages:
        // 01ff -> 0200
        if check_extra_clock and page != new_page {
            .clock += 1
        }

        return .system.read_byte(address)
    }

    function absolute_y_set(mut this, value: u8) {
        let arg_address = .pc + 1
        let address = .system.read_word(address: arg_address)

        .system.write_byte(address: unchecked_add<u16>(.y as! u16, address), value)
    }
    
    function test_nz_flags(mut this, value: u8) {
        .negative = (value & 0x80) == 0x80
        .zero = value == 0
    }

    function ora(mut this, opcode: u8) {
        match opcode {
            0x09 => {
                .a = .a | .immediate()
                .clock += 2
                .pc += 2
            }
            0x05 => {
                .a = .a | .zero_page()
                .clock += 3
                .pc += 2
            }
            0x15 => {
                .a = .a | .zero_page_x()
                .clock += 4
                .pc += 2
            }
            0x01 => {
                .a = .a | .indirect_zero_page_x()
                .clock += 6
                .pc += 2
            }
            0x11 => {
                .a = .a | .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
            }
            0x0d => {
                .a = .a | .absolute()
                .clock += 4
                .pc += 3
            }
            0x1d => {
                .a = .a | .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            0x19 => {
                .a = .a | .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            else => {
                eprintln("{:0>4x}: unknown opcode", .pc)
            }
        }
        .test_nz_flags(value: .a)
    }

    function and_opcode(mut this, opcode: u8) {
        match opcode {
            0x29 => {
                .a = .a & .immediate()
                .clock += 2
                .pc += 2
            }
            0x25 => {
                .a = .a & .zero_page()
                .clock += 3
                .pc += 2
            }
            0x35 => {
                .a = .a & .zero_page_x()
                .clock += 4
                .pc += 2
            }
            0x21 => {
                .a = .a & .indirect_zero_page_x()
                .clock += 6
                .pc += 2
            }
            0x31 => {
                .a = .a & .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
            }
            0x2d => {
                .a = .a & .absolute()
                .clock += 4
                .pc += 3
            }
            0x3d => {
                .a = .a & .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            0x39 => {
                .a = .a & .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            else => {
                eprintln("{:0>4x}: unknown opcode", .pc)
            }
        }
        .test_nz_flags(value: .a)
    }

    function eor(mut this, opcode: u8) {
        match opcode {
            0x49 => {
                .a = .a ^ .immediate()
                .clock += 2
                .pc += 2
            }
            0x45 => {
                .a = .a ^ .zero_page()
                .clock += 3
                .pc += 2
            }
            0x55 => {
                .a = .a ^ .zero_page_x()
                .clock += 4
                .pc += 2
            }
            0x41 => {
                .a = .a ^ .indirect_zero_page_x()
                .clock += 6
                .pc += 2
            }
            0x51 => {
                .a = .a ^ .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
            }
            0x4d => {
                .a = .a ^ .absolute()
                .clock += 4
                .pc += 3
            }
            0x5d => {
                .a = .a ^ .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            0x59 => {
                .a = .a ^ .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
            }
            else => {
                eprintln("{:0>4x}: unknown opcode", .pc)
            }
        }
        .test_nz_flags(value: .a)
    }

    function adder(mut this, accumulator: u8, operand: u8, carry: bool) -> u8 {
        // TODO: decimal mode
        let a = accumulator as! u16;
        let b = operand as! u16;
        let c = carry as! u16;
        let intermediate = a + b + c
        .carry = intermediate > 0xFF
        let result: u8 = as_truncated(intermediate)
        .test_nz_flags(value: result)
        return result
    }

    function adder_with_overflow(mut this, accumulator: u8, operand: u8, carry: bool) -> u8 {
        let result = .adder(accumulator, operand, carry);
        .overflow = ((result ^ accumulator) & (result ^ operand) & 0x80) != 0
        return result
    }

    function adc(mut this, opcode: u8) {
        let operand = match opcode {
            0x69 => {
                let tmp = .immediate()
                .clock += 2
                .pc += 2
                yield tmp
            }
            0x65 => {
                let tmp = .zero_page()
                .clock += 3
                .pc += 2
                yield tmp
            }
            0x75 => {
                let tmp = .zero_page_x()
                .clock += 4
                .pc += 2
                yield tmp
            }
            0x61 => {
                let tmp = .indirect_zero_page_x()
                .clock += 6
                .pc += 2
                yield tmp
            }
            0x71 => {
                let tmp = .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
                yield tmp
            }
            0x6d => {
                let tmp = .absolute()
                .clock += 4
                .pc += 3
                yield tmp
            }
            0x7d => {
                let tmp = .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
                yield tmp
            }
            0x79 => {
                let tmp = .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0
            }
        }
        // Perform subtraction with carry: a + b + c
        .a = .adder_with_overflow(accumulator: .a, operand, carry: .carry)
    }

    function sbc(mut this, opcode: u8) {
        let operand = match opcode {
            0xe9 => {
                let tmp = .immediate()
                .clock += 2
                .pc += 2
                yield tmp
            }
            0xe5 => {
                let tmp = .zero_page()
                .clock += 3
                .pc += 2
                yield tmp
            }
            0xf5 => {
                let tmp = .zero_page_x()
                .clock += 4
                .pc += 2
                yield tmp
            }
            0xe1 => {
                let tmp = .indirect_zero_page_x()
                .clock += 6
                .pc += 2
                yield tmp
            }
            0xf1 => {
                let tmp = .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
                yield tmp
            }
            0xed => {
                let tmp = .absolute()
                .clock += 4
                .pc += 3
                yield tmp
            }
            0xfd => {
                let tmp = .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
                yield tmp
            }
            0xf9 => {
                let tmp = .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0
            }
        }
        // Perform subtraction with borrow: a - b - ~c

        .a = .adder_with_overflow(accumulator: .a, operand: ~operand, carry: .carry)
    }

    function cmp(mut this, opcode: u8) {
        let operand = match opcode {
            0xc9 => {
                let tmp = .immediate()
                .clock += 2
                .pc += 2
                yield tmp
            }
            0xc5 => {
                let tmp = .zero_page()
                .clock += 3
                .pc += 2
                yield tmp
            }
            0xd5 => {
                let tmp = .zero_page_x()
                .clock += 4
                .pc += 2
                yield tmp
            }
            0xc1 => {
                let tmp = .indirect_zero_page_x()
                .clock += 6
                .pc += 2
                yield tmp
            }
            0xd1 => {
                let tmp = .indirect_zero_page_y(check_extra_clock: true)
                .clock += 5
                .pc += 2
                yield tmp
            }
            0xcd => {
                let tmp = .absolute()
                .clock += 4
                .pc += 3
                yield tmp
            }
            0xdd => {
                let tmp = .absolute_x(check_extra_clock: true)
                .clock += 4
                .pc += 3
                yield tmp
            }
            0xd9 => {
                let tmp = .absolute_y(check_extra_clock: true)
                .clock += 4
                .pc += 3
                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0
            }
        }
        // Perform subtraction to set flags
        .adder(accumulator: .a, operand: ~operand, carry: true)
    }

    function cpx(mut this, opcode: u8) {
        let intermediate = match opcode {
            0xe0 => {
                let tmp = .x as! i16 - .immediate() as! i16
                .clock += 2
                .pc += 2
                yield tmp
            }
            0xe4 => {
                let tmp = .x as! i16 - .zero_page() as! i16
                .clock += 3
                .pc += 2
                yield tmp
            }
            0xec => {
                let tmp = .x as! i16 - .absolute() as! i16
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0i16
            }
        }
        .carry = intermediate >= 0
        .zero = intermediate == 0
        .negative = (intermediate & 0x80) == 0x80
    }

    function cpy(mut this, opcode: u8) {
        let intermediate = match opcode {
            0xc0 => {
                let tmp = .y as! i16 - .immediate() as! i16 
                .clock += 2
                .pc += 2
                yield tmp
            }
            0xc4 => {
                let tmp = .y as! i16 - .zero_page() as! i16
                .clock += 3
                .pc += 2
                yield tmp
            }
            0xcc => {
                let tmp = .y as! i16 - .absolute() as! i16
                .clock += 4
                .pc += 3

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0i16
            }
        }
        .carry = intermediate >= 0
        .zero = intermediate == 0
        .negative = (intermediate & 0x80) == 0x80
    }

    function dec(mut this, opcode: u8) {
        match opcode {
            0xc6 => {
                mut intermediate = .zero_page()
                intermediate--
                .test_nz_flags(value: intermediate)
                .zero_page_set(value: intermediate)

                .pc += 2
                .clock += 5
            }
            0xd6 => {
                mut intermediate = .zero_page_x()
                intermediate--
                .test_nz_flags(value: intermediate)
                .zero_page_x_set(value: intermediate)

                .pc += 2
                .clock += 6
            }
            0xce => {
                mut intermediate = .absolute()
                intermediate--
                .test_nz_flags(value: intermediate)
                .absolute_set(value: intermediate)

                .pc += 3
                .clock += 6
            }
            0xde => {
                mut intermediate = .absolute_x(check_extra_clock: false)
                intermediate--
                .test_nz_flags(value: intermediate)
                .absolute_x_set(value: intermediate)

                .pc += 3
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }            
        }
    }

    function dex(mut this) {
        .pc += 1
        .clock += 2
        .x--
        .test_nz_flags(value: .x)
    }

    function dey(mut this) {
        .pc += 1
        .clock += 2
        .y--
        .test_nz_flags(value: .y)
    }

    function inc(mut this, opcode: u8) {
        match opcode {
            0xe6 => {
                mut intermediate = .zero_page()
                intermediate++
                .test_nz_flags(value: intermediate)
                .zero_page_set(value: intermediate)

                .pc += 2
                .clock += 5
            }
            0xf6 => {
                mut intermediate = .zero_page_x()
                intermediate++
                .test_nz_flags(value: intermediate)
                .zero_page_x_set(value: intermediate)

                .pc += 2
                .clock += 6
            }
            0xee => {
                mut intermediate = .absolute()
                intermediate++
                .test_nz_flags(value: intermediate)
                .absolute_set(value: intermediate)

                .pc += 3
                .clock += 6
            }
            0xfe => {
                mut intermediate = .absolute_x(check_extra_clock: false)
                intermediate++
                .test_nz_flags(value: intermediate)
                .absolute_x_set(value: intermediate)

                .pc += 3
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }            
        }
    }

    function inx(mut this) {
        .pc += 1
        .clock += 2
        .x++
        .test_nz_flags(value: .x)
    }

    function iny(mut this) {
        .pc += 1
        .clock += 2
        .y++
        .test_nz_flags(value: .y)
    }

    function asl(mut this, opcode: u8) {
        match opcode {
            0x0a => {
                .carry = (.a & 0x80) == 0x80
                .a = .a << 1
                .test_nz_flags(value: .a)
                .pc += 1
                .clock += 2
            }
            0x06 => {
                mut tmp = .zero_page()
                .carry = (tmp & 0x80) == 0x80
                tmp = tmp << 1
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x16 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x80) == 0x80
                tmp = tmp << 1
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x0e => {
                mut tmp = .absolute()
                .carry = (tmp & 0x80) == 0x80
                tmp = tmp << 1
                .test_nz_flags(value: tmp)
                .absolute_set(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x1e => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x80) == 0x80
                tmp = tmp << 1
                .test_nz_flags(value: tmp)
                .absolute_x_set(value: tmp)
                .pc += 3
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function rol(mut this, opcode: u8) {
        let carry_value = match .carry {
            true => 1u8
            else => 0u8
        }

        match opcode {
            0x2a => {
                .carry = (.a & 0x80) == 0x80
                .a = (.a << 1) + carry_value
                .test_nz_flags(value: .a)
                .pc += 1
                .clock += 2
            }
            0x26 => {
                mut tmp = .zero_page()
                .carry = (tmp & 0x80) == 0x80
                tmp = (tmp << 1) + carry_value
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x36 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x80) == 0x80
                tmp = (tmp << 1) + carry_value
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x2e => {
                mut tmp = .absolute()
                .carry = (tmp & 0x80) == 0x80
                tmp = (tmp << 1) + carry_value
                .test_nz_flags(value: tmp)
                .absolute_set(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x3e => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x80) == 0x80
                tmp = (tmp << 1) + carry_value
                .test_nz_flags(value: tmp)
                .absolute_x_set(value: tmp)
                .pc += 3
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function lsr(mut this, opcode: u8) {
        match opcode {
            0x4a => {
                .carry = (.a & 0x1) == 0x1
                .a = .a >> 1
                .test_nz_flags(value: .a)
                .pc += 1
                .clock += 2
            }
            0x46 => {
                mut tmp = .zero_page()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x56 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x4e => {
                mut tmp = .absolute()
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .test_nz_flags(value: tmp)
                .absolute_set(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x5e => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x01) == 0x01
                tmp = tmp >> 1
                .test_nz_flags(value: tmp)
                .absolute_x_set(value: tmp)
                .pc += 3
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function ror(mut this, opcode: u8) {
        let carry_value = match .carry {
            true => 0x80u8
            else => 0u8
        }

        match opcode {
            0x6a => {
                .carry = (.a & 0x01) == 0x01
                .a = (.a >> 1) + carry_value
                .test_nz_flags(value: .a)
                .pc += 1
                .clock += 2
            }
            0x66 => {
                mut tmp = .zero_page()
                .carry = (tmp & 0x01) == 0x01
                tmp = (tmp >> 1) + carry_value
                .test_nz_flags(value: tmp)
                .zero_page_set(value: tmp)
                .pc += 2
                .clock += 5
            }
            0x76 => {
                mut tmp = .zero_page_x()
                .carry = (tmp & 0x01) == 0x01
                tmp = (tmp >> 1) + carry_value
                .test_nz_flags(value: tmp)
                .zero_page_x_set(value: tmp)
                .pc += 2
                .clock += 6
            }
            0x6e => {
                mut tmp = .absolute()
                .carry = (tmp & 0x01) == 0x01
                tmp = (tmp >> 1) + carry_value
                .test_nz_flags(value: tmp)
                .absolute_set(value: tmp)
                .pc += 3
                .clock += 6
            }
            0x7e => {
                mut tmp = .absolute_x(check_extra_clock: false)
                .carry = (tmp & 0x01) == 0x01
                tmp = (tmp >> 1) + carry_value
                .test_nz_flags(value: tmp)
                .absolute_x_set(value: tmp)
                .pc += 3
                .clock += 7
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    public function lda(mut this, opcode: u8) {
        let intermediate: u8 = match opcode {
            0xa9 => {
                let tmp = .immediate()
                .pc += 2
                .clock += 2

                yield tmp
            }
            0xa5 => {
                let tmp = .zero_page()
                .pc += 2
                .clock += 3

                yield tmp
            }
            0xb5 => {
                let tmp = .zero_page_x()
                .pc += 2
                .clock += 4

                yield tmp
            }
            0xad => {
                let tmp = .absolute()
                .pc += 3
                .clock += 4

                yield tmp
            }
            0xbd => {
                let tmp = .absolute_x(check_extra_clock: true)
                .pc += 3
                .clock += 4

                yield tmp
            }
            0xb9 => {
                let tmp = .absolute_y(check_extra_clock: true)
                .pc += 3
                .clock += 4

                yield tmp
            }
            0xa1 => {
                let tmp = .indirect_zero_page_x()
                .pc += 2
                .clock += 6

                yield tmp
            }
            0xb1 => {
                let tmp = .indirect_zero_page_y(check_extra_clock: true)
                .pc += 2
                .clock += 5

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0u8
            }
        }

        // set the flags
        .test_nz_flags(value: intermediate)

        .a = intermediate
    }

    public function ldx(mut this, opcode: u8) {
        let intermediate: u8 = match opcode {
            0xa2 => {
                let tmp = .immediate()
                .clock += 2
                .pc += 2

                yield tmp
            }
            0xa6 => {
                let tmp = .zero_page()
                .pc += 2
                .clock += 3

                yield tmp
            }
            0xb6 => {
                let tmp = .zero_page_y()
                .pc += 2
                .clock += 4

                yield tmp
            }
            0xae => {
                let tmp = .absolute()
                .pc += 3
                .clock += 4

                yield tmp
            }
            0xbe => {
                let tmp = .absolute_y(check_extra_clock: true)
                .pc += 3
                .clock += 4

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0u8
            }           
        }

        // set the flags
        .test_nz_flags(value: intermediate)

        .x = intermediate
    }

    public function ldy(mut this, opcode: u8) {
        let arg_address = .pc + 1

        let intermediate: u8 = match opcode {
            0xa0 => {
                let tmp = .immediate()
                .pc += 2
                .clock += 2

                yield tmp
            }
            0xa4 => {
                let tmp = .zero_page()
                .pc += 2
                .clock += 3

                yield tmp
            }
            0xb4 => {
                let tmp = .zero_page_x()
                .pc += 2
                .clock += 4

                yield tmp
            }
            0xac => {
                let tmp = .absolute()
                .pc += 3
                .clock += 4

                yield tmp
            }
            0xbc => {
                let tmp = .absolute_x(check_extra_clock: true)
                .pc += 3
                .clock += 4

                yield tmp
            }
            else => {
                eprintln("unknown opcode")
                yield 0u8
            }           
        }

        // set the flags
        .test_nz_flags(value: intermediate)

        .y = intermediate
    }

    function sta(mut this, opcode: u8) {
        let arg_address = .pc + 1

        match opcode {
            0x85 => {
                // Zero page
                .pc += 2
                .clock += 3

                let address = .system.read_byte(address: arg_address)
                .system.write_byte(address: address as! u16, value: .a)
            }
            0x95 => {
                // Zero page, x
                .pc += 2
                .clock += 4

                let address = .system.read_byte(address: arg_address)
                // TODO: does this wrap around the zero page?
                .system.write_byte(address: unchecked_add<u8>(address, .x) as! u16, value: .a)
            }
            0x8d => {
                // Absolute
                .pc += 3
                .clock += 4

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address, value: .a)
            }
            0x9d => {
                // Absolute, X
                .pc += 3
                .clock += 5

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address: address + .x as! u16, value: .a)
            }
            0x99 => {
                // Absolute, Y
                .pc += 3
                .clock += 5

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address: address + .y as! u16, value: .a)
            }
            0x81 => {
                // Indirect, X
                .pc += 2
                .clock += 6

                let address = unchecked_add<u8>(.system.read_byte(address: arg_address), .x) as! u16
                let new_address = .system.read_word_wrapped(address)
                .system.write_byte(address: new_address, value: .a)
            }
            0x91 => {
                // Indirect, Y
                .pc += 2
                .clock += 6

                let address = (.system.read_byte(address: arg_address)) as! u16

                let pre_index = .system.read_word(address)

                let new_address = pre_index + .y as! u16

                .system.write_byte(address: new_address, value: .a)
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function stx(mut this, opcode: u8) {
        let arg_address = .pc + 1

        match opcode {
            0x86 => {
                // Zero page
                .pc += 2
                .clock += 3

                let address = .system.read_byte(address: arg_address)
                .system.write_byte(address: address as! u16, value: .x)
            }
            0x96 => {
                // Zero page, Y
                .pc += 2
                .clock += 4

                let address = .system.read_byte(address: arg_address)
                // TODO: does this wrap around the zero page?
                .system.write_byte(address: unchecked_add<u8>(address, .y) as! u16, value: .x)
            }
            0x8e => {
                // Absolute
                .pc += 3
                .clock += 4

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address, value: .x)
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function sty(mut this, opcode: u8) {
        let arg_address = .pc + 1

        match opcode {
            0x84 => {
                // Zero page
                .pc += 2
                .clock += 3

                let address = .system.read_byte(address: arg_address)
                .system.write_byte(address: address as! u16, value: .y)
            }
            0x94 => {
                // Zero page, X
                .pc += 2
                .clock += 4

                let address = .system.read_byte(address: arg_address)
                // TODO: does this wrap around the zero page?
                .system.write_byte(address: unchecked_add<u8>(address, .x) as! u16, value: .y)
            }
            0x8c => {
                // Absolute
                .pc += 3
                .clock += 4

                let address = .system.read_word(address: arg_address)
                .system.write_byte(address, value: .y)
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function tax(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .a)

        .x = .a
    }

    function txa(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .x)

        .a = .x
    }

    function tay(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .a)

        .y = .a
    }

    function tya(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .y)

        .a = .y
    }

    function tsx(mut this) {
        .pc += 1
        .clock += 2

        // set the flags
        .test_nz_flags(value: .s)

        .x = .s
    }

    function txs(mut this) {
        .pc += 1
        .clock += 2

        .s = .x
    }

    function pla(mut this) {
        .pc += 1
        .clock += 4

        .s += 1
        let intermediate = .system.read_byte(address: 0x100u16 + .s as! u16)

        // set the flags
        .test_nz_flags(value: intermediate)
        .a = intermediate
    }

    function pha(mut this) {
        .pc += 1
        .clock += 3

        .system.write_byte(address: 0x100u16 + .s as! u16, value: .a)
        .s -= 1
    }

    function pull_status(mut this) {
        .s += 1
        let intermediate = .system.read_byte(address: 0x100u16 + .s as! u16)

        .negative = ((intermediate & 0x80) == 0x80)
        .overflow = ((intermediate & 0x40) == 0x40)
        .decimal = ((intermediate & 0x08) == 0x08)
        .interrupt_disable = ((intermediate & 0x04) == 0x04)
        .zero = ((intermediate & 0x02) == 0x02)
        .carry = ((intermediate & 0x01) == 0x01)
    }

    function pull_pc(mut this) {
        .s += 1
        .pc = .system.read_word(address: 0x100u16 + .s as! u16)
        .s += 1
    }

    function plp(mut this) {
        .pc += 1
        .clock += 4

        .pull_status()
    }

    function push_status(mut this) {
        mut intermediate = 0u8
        if .negative {
            intermediate |= 0x80
        }
        if .overflow {
            intermediate |= 0x40
        }
        
        intermediate |= 0x20

        if .break_flag {
            intermediate |= 0x10
        }
        if .decimal {
            intermediate |= 0x08
        }
        if .interrupt_disable {
            intermediate |= 0x04
        }
        if .zero {
            intermediate |= 0x02
        }
        if .carry {
            intermediate |= 0x1
        }

        .system.write_byte(address: 0x100u16 + .s as! u16, value: intermediate)
        .s -= 1
    }

    function push_byte(mut this, anon value: u8) {
        .system.write_byte(address: (0x100u16 + .s as! u16), value)
        .s -= 1
    }

    function push_word(mut this, value: u16) {
        let first_byte = (value >> 8) as! u8
        .push_byte(first_byte)

        let second_byte = (value & 0xff) as! u8
        .push_byte(second_byte)
    }

    function php(mut this) {
        .pc += 1
        .clock += 3

        .push_status()
    }

    function branch(mut this) {
        let arg_address = .pc + 1
        let offset = .system.read_byte(address: arg_address)

        // The 6502 would have the PC on the next opcode now and everything is
        // based upon that. Lets emulate that which also makes the code look cleaner
        .pc += 2

        let prev_page = .pc >> 8
        .pc = unchecked_add(.pc, sxb(value: offset))
        let new_page = .pc >> 8

        if prev_page != new_page {
            .clock += 4
        } else {
            .clock += 3
        }
    }

    function bpl(mut this) {
        if not .negative {
            .branch()
        } else {
            .pc += 2
            .clock += 2
        }
    }

    function bmi(mut this) {
        if .negative {
            .branch()
        } else {
            .pc += 2
            .clock += 2
        }
    }

    function bvc(mut this) {
        if not .overflow {
            .branch()
        } else {
            .pc += 2
            .clock += 2
        }
    }

    function bvs(mut this) {
        if .overflow {
            .branch()
        } else {
            .pc += 2
            .clock += 2
        }
    }

    function bcc(mut this) {
        if not .carry {
            .branch()
        } else {
            .pc += 2
            .clock += 2
        }
    }

    function bcs(mut this) {
        if .carry {
            .branch()
        } else {
            .pc += 2
            .clock += 2
        }
    }

    function bne(mut this) {
        if not .zero {
            .branch()
        } else {
            .pc += 2
            .clock += 2
        }
    }

    function beq(mut this) {
        if .zero {
            .branch()
        } else {
            .pc += 2
            .clock += 2
        }
    }

    function brk(mut this) -> void {
        .push_word(value: .pc + 2)
        .push_status()

        .clock += 7

        .pc = .system.read_word(address: 0xfffe)
        .break_flag = true
        .interrupt_disable = true
    }

    function rti(mut this) {
        .clock += 6

        .pull_status()
        .pull_pc()
    }

    function jsr(mut this) {
        // .pc is at the current opcode, so next pc is + 3
        .push_word(value: .pc + 2)

        .clock += 6

        let arg_address = .pc + 1
        .pc = .system.read_word(address: arg_address)
    }

    function rts(mut this) {
        .clock += 6
        .pull_pc()
        .pc += 1
    }

    function jmp(mut this, opcode: u8) {
        let arg_address = .pc + 1

        match opcode {
            0x4c => {
                let address = .system.read_word(address: arg_address)
                .clock += 3
                .pc = address
            }
            0x6c => {
                let indirect_address = .system.read_word(address: arg_address)

                let address = .system.read_word_wrapped(address: indirect_address)
                .clock += 5
                .pc = address
            }
            else => {
                eprintln("unknown opcode")
            }
        }
    }

    function bit(mut this, opcode: u8) {
        let arg_address = .pc + 1

        let value = match opcode {
            0x24 => {
                .pc += 2
                .clock += 3

                let address = .system.read_byte(address: arg_address)
                let value = .system.read_byte(address: address as! u16)
                yield value
            }
            0x2c => {
                .pc += 3
                .clock += 4

                let address = .system.read_word(address: arg_address)
                let value = .system.read_byte(address: address)
                yield value
            }
            else => {
                eprintln("unknown opcode")
                yield 0u8
            }
        }

        .zero = (value & .a) == 0
        .negative = (value & 0x80) == 0x80
        .overflow = (value & 0x40) == 0x40
    }

    function clc(mut this) {
        .carry = false
        .pc += 1
        .clock += 2
    }

    function sec(mut this) {
        .carry = true
        .pc += 1
        .clock += 2
    }

    function cld(mut this) {
        .decimal = false
        .pc += 1
        .clock += 2
    }

    function sed(mut this) {
        .decimal = true
        .pc += 1
        .clock += 2
    }

    function cli(mut this) {
        .interrupt_disable = false
        .pc += 1
        .clock += 2
    }

    function sei(mut this) {
        .interrupt_disable = true
        .pc += 1
        .clock += 2
    }

    function clv(mut this) {
        .overflow = false
        .pc += 1
        .clock += 2
    }

    function nop(mut this) {
        .pc += 1
        .clock += 2
    }

    // The "illegal" opcodes follow

    function illegal_nop(mut this, opcode: u8)  {
        match opcode {
            0x1a => {
                .pc += 1
                .clock += 2
            }
            0x3a => {
                .pc += 1
                .clock += 2
            }
            0x5a => {
                .pc += 1
                .clock += 2
            }
            0x7a => {
                .pc += 1
                .clock += 2
            }
            0xda => {
                .pc += 1
                .clock += 2
            }
            0xfa => {
                .pc += 1
                .clock += 2
            }
            0x80 => {
                .pc +=  2
                .clock += 2 
            }
            0x82 => {
                .pc +=  2
                .clock += 2 
            }
            0x89 => {
                .pc +=  2
                .clock += 2 
            }
            0xc2 => {
                .pc +=  2
                .clock += 2 
            }
            0xe2 => {
                .pc +=  2
                .clock += 2 
            }
            0x04 => {
                .pc += 2
                .clock += 3
            }
            0x44 => {
                .pc += 2
                .clock += 3
            }
            0x64 => {
                .pc += 2
                .clock += 3
            }
            0x14 => {
                .pc += 2
                .clock += 4
            }
            0x34 => {
                .pc += 2
                .clock += 4
            }
            0x54 => {
                .pc += 2
                .clock += 4
            }
            0x74 => {
                .pc += 2
                .clock += 4
            }
            0xd4 => {
                .pc += 2
                .clock += 4
            }
            0xf4 => {
                .pc += 2
                .clock += 4
            }
            0x0c => {
                .pc += 3
                .clock += 4
            }
            0x1c => {
                .absolute_x(check_extra_clock: true)
                .pc += 3
                .clock += 4
            }
            0x3c => {
                .absolute_x(check_extra_clock: true)
                .pc += 3
                .clock += 4
            }
            0x5c => {
                .absolute_x(check_extra_clock: true)
                .pc += 3
                .clock += 4
            }
            0x7c => {
                .absolute_x(check_extra_clock: true)
                .pc += 3
                .clock += 4
            }
            0xdc => {
                .absolute_x(check_extra_clock: true)
                .pc += 3
                .clock += 4
            }
            0xfc => {
                .absolute_x(check_extra_clock: true)
                .pc += 3
                .clock += 4
            }
            else => {abort()}
        }
    }

    function alr(mut this) {
        // A AND oper; LSR
        // immediate only
        .a = .a & .immediate()
        .carry = (.a & 0x1) == 0x1
        .a = .a >> 11
        .test_nz_flags(value: .a)
        .pc += 2
        .clock += 2
    }

    function anc(mut this) {
        .a  = .a & .immediate()
        .carry = (.a & 0x80) == 0x80
        .pc += 2
        .clock += 2
    }

    function ane(mut this) {
        // Highly unstable, do not use.
        // A base value in A is determined based on the contets of A and a constant, which may be typically $00, $ff, $ee, etc. The value of this constant depends on temerature, the chip series, and maybe other factors, as well.
        // In order to eliminate these uncertaincies from the equation, use either 0 as the operand or a value of $FF in the accumulator.
        // (A OR CONST) AND X AND oper -> A
        eprintln("The effect of this opcode are pure magic and depend on all kinds of physical influences. Not emulating.")
        abort()
    }

    function arr(mut this) {
        // AND + ROR
        // To whomever wants to make this support decimal mode: Good luck
        // Please stop here, the NES doesn't support decimal mode

        let carry_value  = match .carry {
            true => 0x80u8
            else => 0
        }
        let oper  =  .immediate()
        .a = .a & oper
        .a = .a >> 1
        //.carry = (.a & 0x1) == 0x1 // since we trample over this anyways, we can ignore it
        .a |= carry_value
        .test_nz_flags(value: .a)
        .carry = (.a & 0x20) == 0x20

        .overflow = ((.a & 0x20) == 0x20) ^ ((.a  & 0x10) == 0x10)

        .pc += 2
        .clock += 2
    }

    function dcp(mut this, opcode: u8) {
        // DEC + CMP
        match opcode {
            0xc7 => {
                mut intermediate  = .zero_page()
                intermediate--
                .adder(accumulator: .a, operand: ~intermediate, carry: true)
                .zero_page_set(value: intermediate)

                .pc += 2
                .clock  += 5
            }
            0xd7 => {
                mut intermediate  = .zero_page_x()
                intermediate--
                .adder(accumulator: .a, operand: ~intermediate, carry: true)
                .zero_page_x_set(value: intermediate)
                .pc += 2
                .clock  += 6
            }
            0xcf => {
                mut intermediate  = .absolute()
                intermediate--
                .adder(accumulator: .a, operand: ~intermediate, carry: true)
                .absolute_set(value: intermediate)
                .pc += 3
                .clock  += 6
            }
            0xdf => {
                mut intermediate  =  .absolute_x(check_extra_clock: false)
                intermediate--
                .adder(accumulator: .a, operand: ~intermediate, carry: true)
                .absolute_x_set(value: intermediate)
                .pc += 3
                .clock  += 7
            }
            0xdb => {
                mut intermediate  = .absolute_y(check_extra_clock: false)
                intermediate--
                .adder(accumulator: .a, operand: ~intermediate, carry: true)
                .absolute_y_set(value: intermediate)
                .pc += 3
                .clock  += 7
            }
            0xc3 => {
                mut intermediate  = .indirect_zero_page_x()
                intermediate--
                .adder(accumulator: .a, operand: ~intermediate, carry: true)
                .indirect_zero_page_x_set(value: intermediate)
                .pc += 2
                .clock  += 8
            }
            0xd3 => {
                mut intermediate  = .indirect_zero_page_y(check_extra_clock: false)
                intermediate--
                .adder(accumulator: .a, operand: ~intermediate, carry: true)
                .indirect_zero_page_y_set(value: intermediate)
                .pc += 2
                .clock  += 8
            }
            else => {abort()}
        }
    }

    function isc(mut this, opcode: u8){
        match opcode {
            0xe7 => {
                mut intermediate = .zero_page()
                intermediate++
                .a = .adder_with_overflow(accumulator: .a, operand: ~intermediate, carry: .carry)
                .zero_page_set(value: intermediate)
                .pc += 2
                .clock += 5
            }
            0xf7 => {
                mut intermediate = .zero_page_x()
                intermediate++
                .a = .adder_with_overflow(accumulator: .a, operand: ~intermediate, carry: .carry)
                .zero_page_x_set(value: intermediate)
                .pc += 2
                .clock += 6
            }
            0xef => {
                mut intermediate = .absolute()
                intermediate++
                .a = .adder_with_overflow(accumulator: .a, operand: ~intermediate, carry: .carry)
                .absolute_set(value: intermediate)
                .pc += 3
                .clock += 6
            }
            0xff => {
                mut intermediate = .absolute_x(check_extra_clock: false)
                intermediate++
                .a = .adder_with_overflow(accumulator: .a, operand: ~intermediate, carry: .carry)
                .absolute_x_set(value: intermediate)
                .pc += 3
                .clock += 7
            }
            0xfb => {
                mut intermediate =  .absolute_y(check_extra_clock: false)
                intermediate++
                .a = .adder_with_overflow(accumulator: .a, operand: ~intermediate, carry: .carry)
                .absolute_y_set(value: intermediate)
                .pc += 3
                .clock += 7
            }
            0xe3 => {
                mut intermediate = .indirect_zero_page_x()
                intermediate++
                .a = .adder_with_overflow(accumulator: .a, operand: ~intermediate, carry: .carry)
                .indirect_zero_page_x_set(value: intermediate)
                .pc += 2
                .clock += 8
            }
            0xf3 => {
                mut intermediate = .indirect_zero_page_y(check_extra_clock: false)
                intermediate++
                .a = .adder_with_overflow(accumulator: .a, operand: ~intermediate, carry: .carry)
                .indirect_zero_page_y_set(value: intermediate)
                .pc += 2
                .clock += 8
            }
            else => {abort()}
        }
    }

    function las(mut this){
        // LDA + TSX
        let intermediate = .absolute_y(check_extra_clock: true) & .s
        .a = intermediate
        .x = intermediate
        //.s = intermediate // The doc indicates this, but I'm not to sure about it
        .test_nz_flags(value: intermediate)

        .pc += 3
        .clock += 4
    }

    function lax(mut this, opcode: u8) {
        let (intermediate, pc: u16, clock: u64) = match opcode {
            0xa7 => {
                yield (.zero_page(), 2, 3)
            }
            0xb7 => {
                yield (.zero_page_y(), 2, 4)
            }
            0xaf => {
                yield (.absolute(), 3, 4)
            }
            0xbf => {
                yield (.absolute_y(check_extra_clock: true), 3, 4)
            }
            0xa3 => {
                yield (.indirect_zero_page_x(), 2, 6)
            }
            0xb3 => {
                yield (.indirect_zero_page_y(check_extra_clock: true), 2, 5)
            }
            else => {abort()}
        }

        .a = intermediate
        .x = intermediate

        .test_nz_flags(value: .a)

        .pc += pc
        .clock += clock
    }

    function lxa(mut this) {
        // This is as unstable and magic as ANE
        .ane()
    }

    function rla(mut this, opcode: u8) {
        //  ROL +  AND
        let carry_value = match .carry {
            true => 1u8
            else => 0u8
        }

        match opcode {
            0x27 => {
                mut intermediate = .zero_page()
                .carry = (intermediate & 0x80) == 0x80
                intermediate = (intermediate << 1) + carry_value
                .a = .a & intermediate
                .test_nz_flags(value: .a)
                .zero_page_set(value: intermediate)
                .pc += 2
                .clock += 5
            }
            0x37 => {
                mut intermediate = .zero_page_x()
                .carry = (intermediate & 0x80) == 0x80
                intermediate = (intermediate << 1) + carry_value
                .a = .a & intermediate
                .test_nz_flags(value: .a)
                .zero_page_x_set(value: intermediate)
                .pc += 2
                .clock += 6
            }
            0x2f => {
                mut intermediate = .absolute()
                .carry = (intermediate & 0x80) == 0x80
                intermediate = (intermediate << 1) + carry_value
                .a = .a & intermediate
                .test_nz_flags(value: .a)
                .absolute_set(value: intermediate)
                .pc += 3
                .clock += 6
            }
            0x3f => {
                mut intermediate = .absolute_x(check_extra_clock: false)
                .carry = (intermediate & 0x80) == 0x80
                intermediate = (intermediate << 1) + carry_value
                .a = .a & intermediate
                .test_nz_flags(value: .a)
                .absolute_x_set(value: intermediate)
                .pc += 3
                .clock += 7
            }
            0x3b => {
                mut intermediate = .absolute_y(check_extra_clock: false)
                .carry = (intermediate & 0x80) == 0x80
                intermediate = (intermediate << 1) + carry_value
                .a = .a & intermediate
                .test_nz_flags(value: .a)
                .absolute_y_set(value: intermediate)
                .pc += 3
                .clock += 7
            }
            0x23 => {
                mut intermediate = .indirect_zero_page_x()
                .carry = (intermediate & 0x80) == 0x80
                intermediate = (intermediate << 1) + carry_value
                .a = .a & intermediate
                .test_nz_flags(value: .a)
                .indirect_zero_page_x_set(value: intermediate)
                .pc += 2
                .clock += 8
            }
            0x33 => {
                mut intermediate = .indirect_zero_page_y(check_extra_clock: false)
                .carry = (intermediate & 0x80) == 0x80
                intermediate = (intermediate << 1) + carry_value
                .a = .a & intermediate
                .test_nz_flags(value: .a)
                .indirect_zero_page_y_set(value: intermediate)
                .pc += 2
                .clock += 8
            }

            else => {abort()}
        }
    }

    function rra(mut this, opcode: u8) {
        // ROR + ADC
        let carry_value = match .carry {
            true => 0x80u8
            else => 0u8
        }
        match opcode {
            0x67 => {
                mut value = .zero_page()
                .carry = (value & 0x1) == 0x1
                value = (value >> 1) + carry_value
                .a = .adder_with_overflow(accumulator: .a, operand: value, carry: .carry)
                .zero_page_set(value)
                .pc += 2
                .clock += 5
            }
            0x77 => {
                mut value = .zero_page_x()
                .carry = (value & 0x1) == 0x1
                value = (value >> 1) + carry_value
                .a = .adder_with_overflow(accumulator: .a, operand: value, carry: .carry)
                .zero_page_x_set(value)
                .pc += 2
                .clock += 6
            }
            0x6f => {
                mut value = .absolute()
                .carry = (value & 0x1) == 0x1
                value = (value >> 1) + carry_value
                .a = .adder_with_overflow(accumulator: .a, operand: value, carry: .carry)
                .absolute_set(value)
                .pc += 3
                .clock += 6
            }
            0x7f => {
                mut value = .absolute_x(check_extra_clock: false)
                .carry = (value & 0x1) == 0x1
                value = (value >> 1) + carry_value
                .a = .adder_with_overflow(accumulator: .a, operand: value, carry: .carry)
                .absolute_x_set(value)
                .pc += 3
                .clock += 7
            }
            0x7b => {
                mut value = .absolute_y(check_extra_clock: false)
                .carry = (value & 0x1) == 0x1
                value = (value >> 1) + carry_value
                .a = .adder_with_overflow(accumulator: .a, operand: value, carry: .carry)
                .absolute_y_set(value)
                .pc += 3
                .clock += 7
            }
            0x63 => {
                mut value = .indirect_zero_page_x()
                .carry = (value & 0x1) == 0x1
                value = (value >> 1) + carry_value
                .a = .adder_with_overflow(accumulator: .a, operand: value, carry: .carry)
                .indirect_zero_page_x_set(value)
                .pc += 2
                .clock += 8
            }
            0x73 => {
                mut value = .indirect_zero_page_y(check_extra_clock: false)
                .carry = (value & 0x1) == 0x1
                value = (value >> 1) + carry_value
                .a = .adder_with_overflow(accumulator: .a, operand: value, carry: .carry)
                .indirect_zero_page_y_set(value)
                .pc += 2
                .clock += 8
            }
            else => {abort()}
        }
        .test_nz_flags(value: .a)
    }

    function sax(mut this, opcode: u8) {
        // STA + STX, but since they are both thrown at the bus, the logic transistors
        // effectively perform an AND between the two values
        let value = .a & .x

        match opcode {
            0x87 => {
                .zero_page_set(value)
                .pc += 2
                .clock += 3
            }
            0x97 => {
                .zero_page_y_set(value)
                .pc += 2
                .clock += 4
            }
            0x8f => {
                .absolute_set(value)
                .pc += 3 
                .clock += 4
            }
            0x83 => {
                .indirect_zero_page_x_set(value)
                .pc += 2
                .clock += 6
            }
            else => {abort()}
        }
    }

    function sbx(mut this) {
        let value = .immediate()
        .x = (.a & .x) - value
        .adder(accumulator: .a, operand: ~value, carry: true)
    }
    
    function sha(mut this, opcode: u8) {
        // Stores A AND X AND (high-byte of addr. + 1) at addr.
        // unstable: sometimes 'AND (H+1)' is dropped, 
        // page boundary crossings may not work 
        // (with the high-byte of the value used as the high-byte of the address)

        // FIXME: figure out how to do the high-byte stuff, rolling drop everytime for now
        let value = .a & .x

        match opcode {
            0x9f => {
                .absolute_y_set(value)
                .pc += 3
                .clock += 5
            }
            0x93 => {
                .indirect_zero_page_y_set(value)
                .pc += 2
                .clock += 6
            }
            else => {abort()}
        }
    }

    function shx(mut this) {
        // Stores X AND (high-byte of addr. + 1) at addr.
        // unstable: sometimes 'AND (H+1)' is dropped, 
        // page boundary crossings may not work 
        // (with the high-byte of the value used as the high-byte of the address)

        // FIXME: figure out how to do the high-byte stuff, rolling drop everytime for now
        let value = .x
        .absolute_y_set(value)
        .pc += 3
        .clock += 5
    }

    function shy(mut this) {
        // Stores Y AND (high-byte of addr. + 1) at addr.
        // unstable: sometimes 'AND (H+1)' is dropped, 
        // page boundary crossings may not work 
        // (with the high-byte of the value used as the high-byte of the address)

        // FIXME: figure out how to do the high-byte stuff, rolling drop everytime for now
        let value = .y
        .absolute_x_set(value)
        .pc += 3
        .clock += 5
    }

    function slo(mut this, opcode: u8) {
        // ASL + ORA
        match opcode {
            0x07 => {
                mut value = .zero_page()
                .carry = (value & 0x80) == 0x80
                value = value << 1
                .zero_page_set(value)
                .a = .a | value
                .pc += 2
                .clock += 5
            }
            0x17 => {
                mut value = .zero_page_x()
                .carry = (value & 0x80) == 0x80
                value = value << 1
                .zero_page_x_set(value)
                .a = .a | value
                .pc += 2
                .clock += 6
            }
            0x0f => {
                mut value = .absolute()
                .carry = (value & 0x80) == 0x80
                value = value << 1
                .absolute_set(value)
                .a = .a | value
                .pc += 3
                .clock += 6
            }
            0x1f => {
                mut value = .absolute_x(check_extra_clock: false)
                .carry = (value & 0x80) == 0x80
                value = value << 1
                .absolute_x_set(value)
                .a = .a | value
                .pc += 3
                .clock += 7
            }
            0x1b => {
                mut value = .absolute_y(check_extra_clock: false)
                .carry = (value & 0x80) == 0x80
                value = value << 1
                .absolute_y_set(value)
                .a = .a | value
                .pc += 3
                .clock += 7
            }
            0x03 => {
                mut value = .indirect_zero_page_x()
                .carry = (value & 0x80) == 0x80
                value = value << 1
                .indirect_zero_page_x_set(value)
                .a = .a | value
                .pc += 2
                .clock += 8
            }
            0x13 => {
                mut value = .indirect_zero_page_y(check_extra_clock: false)
                .carry = (value & 0x80) == 0x80
                value = value << 1
                .indirect_zero_page_y_set(value)
                .a = .a | value
                .pc += 2
                .clock += 8
            }
            else => {abort()}
        }
    }

    function sre(mut this, opcode: u8){
        // LSR +  EOR
        match opcode {
            0x47 => {
                mut value = .zero_page()
                .carry = (value & 0x1) == 0x1
                value = value >> 1
                .zero_page_set(value)
                .a = .a ^ value
                .test_nz_flags(value: .a)
                .pc += 2
                .clock += 5
            }
            0x57 => {
                mut value = .zero_page_x()
                .carry = (value & 0x1) == 0x1
                value = value >> 1
                .zero_page_x_set(value)
                .a = .a ^ value
                .test_nz_flags(value: .a)
                .pc += 2
                .clock += 6
            }
            0x4f => {
                mut value = .absolute()
                .carry = (value & 0x1) == 0x1
                value = value >> 1
                .absolute_set(value)
                .a = .a ^ value
                .test_nz_flags(value: .a)
                .pc += 3
                .clock += 6
            }
            0x5f => {
                mut value = .absolute_x(check_extra_clock: false)
                .carry = (value & 0x1) == 0x1
                value = value >> 1
                .absolute_x_set(value)
                .a = .a ^ value
                .test_nz_flags(value: .a)
                .pc += 3
                .clock += 7
            }
            0x5b => {
                mut value = .absolute_y(check_extra_clock: false)
                .carry = (value & 0x1) == 0x1
                value = value >> 1
                .absolute_y_set(value)
                .a = .a ^ value
                .test_nz_flags(value: .a)
                .pc += 3
                .clock += 7
            }
            0x43 => {
                mut value = .indirect_zero_page_x()
                .carry = (value & 0x1) == 0x1
                value = value >> 1
                .indirect_zero_page_x_set(value)
                .a = .a ^ value
                .test_nz_flags(value: .a)
                .pc += 2
                .clock += 8
            }
            0x53 => {
                mut value = .indirect_zero_page_y(check_extra_clock: false)
                .carry = (value & 0x1) == 0x1
                value = value >> 1
                .indirect_zero_page_y_set(value)
                .a = .a ^ value
                .test_nz_flags(value: .a)
                .pc += 2
                .clock += 8
            }
            else => {abort()}
        }
    }

    function tas(mut this)  {
        // Puts A AND X in SP and stores A AND X AND (high-byte of addr. + 1) at addr.
        // unstable: sometimes 'AND (H+1)' is dropped, 
        // page boundary crossings may not work 
        // (with the high-byte of the value used as the high-byte of the address)

        // FIXME: figure out how to do the high-byte stuff, rolling drop everytime for now
        .s = .a & .x

        .absolute_y_set(value: .a & .x)

        .pc += 3
        .clock += 5
    }

    function usbc(mut this) {
        // SBC + NOP
        .sbc(opcode: 0xe9)
    }

    function jam(mut this) {
        // These instructions freeze the CPU.

        // The processor will be trapped infinitely in T1 
        // phase with $FF on the data bus.  Reset required.
        
        // FIXME: There most likely is a better way 
        eprintln("JAM!")
        while (true) {}
    }
}
