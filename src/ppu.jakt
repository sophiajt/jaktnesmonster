import cart { Mirroring }

class RGB {
    public red: u8
    public green: u8
    public blue: u8

    public function to_u32(this) -> u32 {
    // Order is RGBA for SDL
        return (255 << 24) | (.blue << 16) | (.green << 8) | .red 
    }
}

class Sprite {
    public hflip: bool
    public mask: [u8]
    public bg_sprite: bool
    public sprite_x: u8
    public sprite_zero: bool

    public function get_sprite_pixel(this, x: u8) -> (bool, u8){
        //TODO (?): How did the hardware handle this with 8 bits?
        guard x >= .sprite_x and (x as! u16) < ((.sprite_x as! u16) + 8u16) else {
            return(false, 0u8)
        }

        mut shift_amount = match .hflip {
            true => (x - .sprite_x) as! i16
            else => 7 - (x as! i16 - .sprite_x as! i16)
        }

        if (shift_amount < 0) {
            shift_amount = 0
        }

        let entry = .mask[shift_amount as! u8]

        return (true, entry)
    }
}

class PPU {
    // base_table_address: u16
    vram_address_increment: u16
    sprite_table_address: u16
    background_table_address: u16
    sprite_size_8x8: bool
    public nmi_on_vblank: bool
    clock: u64
    public in_vblank: bool
    dont_vblank: bool
    public nametable_data: [[u8]]
    public nametables: [usize]
    public palette: [u8]
    // public vram_rw_addr: u16
    public oam: [u8]
    oam_addr: u8
    second_oam: [Sprite]
    public chr_rom_pages: [[u8]]
    public chr_rom_page_0000: usize
    public chr_rom_page_1000: usize
    public video_buffer: [u32]
    // scroll_x: u8
    // scroll_y: u8
    // scroll_toggle: bool
    background_visible: bool
    sprites_visible: bool
    buffered_read: u8
    sprite_zero_hit: bool
    sprite_overflow: bool
    public debug: bool
    rendering_enabled: bool
    public even_frame_flag: bool

    left_sprite_mask: bool
    left_bg_mask: bool

    horizontal_pixel: u64
    vertical_pixel: u64
    dma_ticks: u64
    public mapper: u8
    public mmc3_chr_a12_inversion: usize
    public mmc3_chr_rom_2k_bank_0: usize
    public mmc3_chr_rom_2k_bank_1: usize
    public mmc3_chr_rom_1k_bank_0: usize
    public mmc3_chr_rom_1k_bank_1: usize
    public mmc3_chr_rom_1k_bank_2: usize
    public mmc3_chr_rom_1k_bank_3: usize
    public mmc3_irq_counter: u8
    public mmc3_irq_counter_reload: u8
    public mmc3_irq_enabled: bool
    public mmc3_irq_flag: bool
    public mmc3_irq_reload_flag: bool

    // Internal PPU registers (from https://www.nesdev.org/wiki/PPU_scrolling)
    v: u16
    t: u16
    x: u8
    w: u8

    color_palette: [u32]

    public function init(chr_rom_pages: [[u8]], mapper: u8) throws -> PPU {
        mut video_buffer: [u32] = [rgb(0,0,0); 256*240]
        return PPU(
            vram_address_increment: 1
            sprite_table_address: 0x0000
            background_table_address: 0x0000
            sprite_size_8x8: true
            nmi_on_vblank: false
            clock: 0
            in_vblank: false
            dont_vblank: false
            nametable_data: [[0x0; 0x400], [0x0; 0x400], [0x0; 0x400], [0x0; 0x400]]
            nametables: [0; 4]
            palette: [0x0; 32]
            oam: [0xff; 256]
            oam_addr: 0x00
            second_oam: []
            chr_rom_pages
            chr_rom_page_0000: 0
            chr_rom_page_1000: chr_rom_pages.size() - 1
            video_buffer
            background_visible: false
            sprites_visible: false
            buffered_read: 0
            sprite_zero_hit: false
            sprite_overflow: false
            debug: false
            rendering_enabled: false
            even_frame_flag: true
            left_sprite_mask: false
            left_bg_mask: false
            horizontal_pixel: 0
            vertical_pixel: 0
            dma_ticks: 0
            mapper
            mmc3_chr_a12_inversion: 0
            mmc3_chr_rom_2k_bank_0: 0
            mmc3_chr_rom_2k_bank_1: 0
            mmc3_chr_rom_1k_bank_0: 0
            mmc3_chr_rom_1k_bank_1: 0
            mmc3_chr_rom_1k_bank_2: 0
            mmc3_chr_rom_1k_bank_3: 0
            mmc3_irq_counter: 0
            mmc3_irq_counter_reload: 0
            mmc3_irq_enabled: false
            mmc3_irq_flag: false
            mmc3_irq_reload_flag: false

            // internal PPU registers
            v: 0
            t: 0
            x: 0
            w: 0

            color_palette: [
                    rgb(101 101 101)
                    rgb(0    45 105)
                    rgb(19   31 127)
                    rgb(69   19 124)
                    rgb(96   11  98)
                    rgb(115  10  55)
                    rgb(113  15   7)
                    rgb(90   26   0)
                    rgb(52   40   0)
                    rgb(11   52   0)
                    rgb(0   60    0)    
                    rgb(0   61   16)    
                    rgb(0   56   64)
                    rgb(0    0    0)
                    rgb(0    0    0)
                    rgb(0    0    0)
                    rgb(174 174 174)
                    rgb(15   99 179)
                    rgb(64   81 208)
                    rgb(120  65 204)
                    rgb(167  54 169)
                    rgb(192  52 112)
                    rgb(189  60  48)
                    rgb(159  74   0)
                    rgb(109  92   0)
                    rgb(54  109   0)
                    rgb(7   119   4)
                    rgb(0   121  61)
                    rgb(0   114 125)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(254 254 255)
                    rgb(93  179 255)
                    rgb(143 161 255)
                    rgb(200 144 255)
                    rgb(247 133 250)
                    rgb(255 131 192)
                    rgb(255 139 127)
                    rgb(239 154  73)
                    rgb(189 172  44)
                    rgb(133 188  47)
                    rgb(85  199  83)    
                    rgb(60  201 140)    
                    rgb(62  194 205)
                    rgb(78   78  78)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(254 254 255)
                    rgb(188 223 255)
                    rgb(209 216 255)
                    rgb(232 209 255)
                    rgb(251 205 253)
                    rgb(255 204 229)
                    rgb(255 207 202)
                    rgb(248 213 180)
                    rgb(228 220 168)
                    rgb(204 227 169)
                    rgb(185 232 184)    
                    rgb(174 232 208)    
                    rgb(175 229 234)
                    rgb(182 182 182)
                    rgb(0    0    0)
                    rgb(0    0    0)
                ]   
        )
    }

    public function mmc3_clock_irq(mut this) {
        if .mmc3_irq_counter == 0 or .mmc3_irq_reload_flag {
            .mmc3_irq_counter = .mmc3_irq_counter_reload;
            .mmc3_irq_reload_flag = false;
        } else {
            .mmc3_irq_counter--
        }

        if .mmc3_irq_counter == 0 {
            .mmc3_irq_flag = .mmc3_irq_enabled;
        }
    }

    public function mmc3_chr_rom_byte_at(mut this, page: usize, index: u64) -> u8 {
        mut computed_address: u16 = 0x0
        if page == .chr_rom_page_1000 {
            computed_address += 0x1000
        }
        computed_address += index as! u16
        mut computed_page: usize = 0
        mut computed_index: u16 = 0
        mut selected_bank: usize = 0
        mut offset: u16 = 0
        if .mmc3_chr_a12_inversion == 0 {
            match computed_address {
                0x0000u16..0x0800u16 => {
                    // 2 KB CHR bank at PPU $0000-$07FF
                    selected_bank = .mmc3_chr_rom_2k_bank_0
                    offset = 0x0000
                }
                0x0800u16..0x1000u16 => {
                    // 2 KB CHR bank at PPU $0800-$0FFF
                    selected_bank = .mmc3_chr_rom_2k_bank_1
                    offset = 0x0800
                }
                0x1000u16..0x1400u16 => {
                    // 1 KB CHR bank at PPU $1000-$13FF
                    selected_bank = .mmc3_chr_rom_1k_bank_0
                    offset = 0x1000
                }
                0x1400u16..0x1800u16 => {
                    // 1 KB CHR bank at PPU $1400-$17FF
                    selected_bank = .mmc3_chr_rom_1k_bank_1
                    offset = 0x1400
                }
                0x1800u16..0x1c00u16 => {
                    // 1 KB CHR bank at PPU $1800-$1BFF
                    selected_bank = .mmc3_chr_rom_1k_bank_2
                    offset = 0x1800
                }
                0x1c00u16..0x2000u16 => {
                    // 1 KB CHR bank at PPU $1C00-$1FFF
                    selected_bank = .mmc3_chr_rom_1k_bank_3
                    offset = 0x1c00
                }
                else => {
                    return 0
                }
            }
        } else {
            match computed_address {
                0x1000u16..0x1800u16 => {
                    // 2 KB CHR bank at PPU $1000-$17FF
                    selected_bank = .mmc3_chr_rom_2k_bank_0
                    offset = 0x1000
                }
                0x1800u16..0x2000u16 => {
                    // 2 KB CHR bank at PPU $1800-$1FFF
                    selected_bank = .mmc3_chr_rom_2k_bank_1
                    offset = 0x1800
                }
                0x0000u16..0x0400u16 => {
                    // 1 KB CHR bank at PPU $0000-$03FF
                    selected_bank = .mmc3_chr_rom_1k_bank_0
                    offset = 0x0000
                }
                0x0400u16..0x0800u16 => {
                    // 1 KB CHR bank at PPU $0400-$07FF
                    selected_bank = .mmc3_chr_rom_1k_bank_1
                    offset = 0x0400
                }
                0x0800u16..0x0c00u16 => {
                    // 1 KB CHR bank at PPU $0800-$0BFF
                    selected_bank = .mmc3_chr_rom_1k_bank_2
                    offset = 0x0800
                }
                0x0c00u16..0x0000u16 => {
                    // 1 KB CHR bank at PPU $0C00-$0FFF
                    selected_bank = .mmc3_chr_rom_1k_bank_3
                    offset = 0x0c00
                }
                else => {
                    return 0
                }
            }
        }
        computed_page = selected_bank / 4
        computed_index = (selected_bank as! u16 % 4) * 0x0400 + computed_address - offset
        return .chr_rom_pages[computed_page][computed_index]
    }

    public function chr_rom_byte_at(mut this, anon page: usize, anon index: u64) -> u8 {
        return match .mapper {
            4 => .mmc3_chr_rom_byte_at(page, index)
            else => .chr_rom_pages[page][index]
        }
    }

    public function dma_tick(mut this) throws {
        if .even_frame_flag {
            .tick(cycles: 513 * 3u64)
        } else {
            .tick(cycles: 514 * 3u64)
        }
    }

    public function set_mirroring(mut this, anon mirroring: Mirroring) {
        match mirroring {
            Horizontal => {
                .nametables[0] = 0
                .nametables[1] = 0
                .nametables[2] = 1
                .nametables[3] = 1
            }
            Vertical => {
                .nametables[0] = 0
                .nametables[1] = 1
                .nametables[2] = 0
                .nametables[3] = 1
            }
            OneScreenLower => {
                .nametables[0] = 0
                .nametables[1] = 0
                .nametables[2] = 0
                .nametables[3] = 0
            }
            OneScreenUpper => {
                .nametables[0] = 1
                .nametables[1] = 1
                .nametables[2] = 1
                .nametables[3] = 1
            }
        }
    }

    public function tick(mut this, cycles: u64) throws {
        for x in (.clock)..(.clock + cycles) {
            // Where are we on the screen
            .horizontal_pixel = .clock % 341
            .vertical_pixel = .clock / 341

            .render_pixel()
            .clock += 1

            // 257-320 = sprite tile loading interval
            if (.horizontal_pixel == 320) and ((.vertical_pixel >= 0) and (.vertical_pixel <= 239)) {

                // .oam_addr = 0x00
                .second_oam = .find_sprites(scanline: (.vertical_pixel + 1) as! u8)
            }
            if (.vertical_pixel == 241) and (.horizontal_pixel == 0) {
                .dont_vblank = false
            }
            // 240 is the post-render line, vblank is set in 241
            if (.vertical_pixel == 241) and (.horizontal_pixel == 1){
                if not .dont_vblank { .in_vblank = true }
            }
            if (.vertical_pixel == 241) and (.horizontal_pixel == 3) {
                .dont_vblank = false
            }
            // 261 is the pre-render line
            if (.vertical_pixel == 261) and (.horizontal_pixel == 1){
                .in_vblank = false
                .sprite_zero_hit = false
                .sprite_overflow = false
            }
            // Coarse X
            // if (.rendering_enabled) and (.horizontal_pixel % 8 == 0) and ((.horizontal_pixel <= 256) or (.horizontal_pixel > 328)) {
            //    .v += 1
            // }
            if (.horizontal_pixel == 339) and (.vertical_pixel == 261) and (.rendering_enabled) and (.even_frame_flag == false) { .clock = 0 }
            if (.horizontal_pixel == 340) and (.vertical_pixel == 261) { .clock = 0 }
            
            .even_frame_flag = not .even_frame_flag
        }
    }

    function read_nametable(this, anon address: u16) -> u8 {
        match address & 0xfc00 {
            0x2000 => {
                return .nametable_data[.nametables[0]][address & ~0xfc00]
            }
            0x2400 => {
                return .nametable_data[.nametables[1]][address & ~0xfc00]
            }
            0x2800 => {
                return .nametable_data[.nametables[2]][address & ~0xfc00]
            }
            else => {
                return .nametable_data[.nametables[3]][address & ~0xfc00]
            }
        }
    }

    function write_nametable(mut this, address: u16, value: u8) {
        match address & 0xfc00 {
            0x2000 => {
                .nametable_data[.nametables[0]][address & ~0xfc00] = value
            }
            0x2400 => {
                .nametable_data[.nametables[1]][address & ~0xfc00] = value
            }
            0x2800 => {
                .nametable_data[.nametables[2]][address & ~0xfc00] = value
            }
            else => {
                .nametable_data[.nametables[3]][address & ~0xfc00] = value
            }
        }
    }

    function render_bg_pixel(mut this) throws -> bool {
        let scroll_x = (.v & 0x1f) * 8 + .x as! u16
        let scroll_y = ((.v >> 5) & 0x1f) * 8 + (.v >> 12)

        mut virtual_horizontal_pixel = .horizontal_pixel + scroll_x as! u64
        mut virtual_vertical_pixel = scroll_y as! u64

        mut base_table = (.v >> 10) & 0x3

        if virtual_horizontal_pixel >= 256 {
            base_table ^= 0x1
            virtual_horizontal_pixel -= 256
        }

        if virtual_vertical_pixel >= 240 {
            base_table ^= 0x2
            virtual_vertical_pixel -= 240
        }

        // Which tile
        let vertical_tile: u16 = virtual_vertical_pixel / 8
        let horizontal_tile: u16 = virtual_horizontal_pixel / 8

        // Fetch nametable entry
        let nametable_entry = .nametable_data[.nametables[base_table]][vertical_tile * 32 + horizontal_tile]
        
        let vertical_attr = vertical_tile / 4
        let horizontal_attr = horizontal_tile / 4

        // 0000
        // ^^^^  
        // | ||
        // | | plane 0
        // | plane 1
        // attr (2 bits)

        let attr = .nametable_data[.nametables[base_table]][0x3c0 + vertical_attr * 8 + horizontal_attr]

        let horizontal_box_pos = (horizontal_tile % 4) / 2
        let vertical_box_pos = (vertical_tile % 4) / 2

        let color_bits = (attr >> ((horizontal_box_pos * 2) + (vertical_box_pos * 4))) & 0x3

        let first_plane_byte = match .background_table_address {
            0000 => .chr_rom_byte_at(.chr_rom_page_0000, nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8)
            else => .chr_rom_byte_at(.chr_rom_page_1000, nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8)
        }
        let second_plane_byte = match .background_table_address {
            0000 => .chr_rom_byte_at(.chr_rom_page_0000, nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8 + 8)
            else => .chr_rom_byte_at(.chr_rom_page_1000, nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8 + 8)
        }

        let first_plane_bit = first_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1
        let second_plane_bit = second_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1

        let palette_entry = first_plane_bit + (second_plane_bit * 2) + (color_bits * 4)

        if (first_plane_bit == 0) and (second_plane_bit == 0) {
            let rgb = .look_up_palette_entry_bg(palette_entry: 0)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
            return false
        } else {
            let rgb = .look_up_palette_entry_bg(palette_entry)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
            return true
        }
    }

    function render_sprite_pixel(mut this, horizontal_pixel: u8, vertical_pixel: u8, bg_set: bool) throws {
        for sprite in .second_oam {
            let (valid, entry) = sprite.get_sprite_pixel(x: horizontal_pixel)

            if not valid {
                continue
            }

            let transparent = (entry & 0x3) == 0
            
            // TODO: handle 8x16 sprites
            if not transparent {
        
                if not sprite.bg_sprite or not bg_set {
                    let rgb = .look_up_palette_entry_sprite(palette_entry: entry)
                    .video_buffer[vertical_pixel as! u16 * 256u16 + horizontal_pixel as! u16] = rgb
                }
                
                // Sprite zero can be hit from the background too!
                if not .sprite_zero_hit and .horizontal_pixel != 255 {
                    .sprite_zero_hit = (not .sprite_zero_hit) and sprite.sprite_zero and bg_set
                }
            }
        }
    }

    function coarse_x_increment(mut this) {
        // if ((v & 0x001F) == 31) // if coarse X == 31
        //     v &= ~0x001F          // coarse X = 0
        //     v ^= 0x0400           // switch horizontal nametable
        // else
        //     v += 1                // increment coarse X

        if (.v & 0x001f) == 31 {
            .v &= ~0x001fu16
            .v ^= 0x400
        } else {
            .v += 1
        }
    }

    function y_increment(mut this) {
        // if ((v & 0x7000) != 0x7000)        // if fine Y < 7
        //   v += 0x1000                      // increment fine Y
        // else
        //   v &= ~0x7000                     // fine Y = 0
        //   int y = (v & 0x03E0) >> 5        // let y = coarse Y
        //   if (y == 29)
        //     y = 0                          // coarse Y = 0
        //     v ^= 0x0800                    // switch vertical nametable
        //   else if (y == 31)
        //     y = 0                          // coarse Y = 0, nametable not switched
        //   else
        //     y += 1                         // increment coarse Y
        //   v = (v & ~0x03E0) | (y << 5)     // put coarse Y back into v

        if (.mapper == 4) {
            .mmc3_clock_irq()
        }

        if (.v & 0x7000) != 0x7000 {
            .v += 0x1000
        } else {
            .v &= ~0x7000u16
            mut y = (.v & 0x3e0) >> 5
            if y == 29 {
                y = 0
                .v ^= 0x800
            } else if y == 31 {
                y = 0
            } else {
                y += 1
            }
            .v = (.v & ~0x03e0u16) | (y << 5)
        }
    }

    function find_sprites(mut this, scanline: u8) throws -> [Sprite]  {
        mut result: [Sprite] = []
        mut sprite_count = 0

        let sprite_base_table = match .sprite_table_address {
            0000 => .chr_rom_page_0000
            else => .chr_rom_page_1000
        }
        mut sprite_table = sprite_base_table        

        mut sprite_height = 8u8
        if not .sprite_size_8x8 {
            sprite_height = 16u8
        }
        for sprite in (0u8..63u8).inclusive() {
            let sprite_addr = sprite * 4u8
            if .oam[sprite_addr] > 0xee {
                // Ignore any sprite below row 0xee
                continue
            }
            let sprite_y = .oam[sprite_addr] + 1
            let sprite_x = .oam[sprite_addr + 3]

            if not .sprite_size_8x8 {
                if (.oam[sprite_addr + 1] & 0x1) == 0x1 {
                    sprite_table = .chr_rom_page_1000
                } else {
                    sprite_table = .chr_rom_page_0000
                }
            } else {
                sprite_table = sprite_base_table
            }

            if scanline >= sprite_y and scanline < (sprite_y + sprite_height)  {
                if sprite_count >= 8 {
                    //println("Sprite overflow, {} entries in second OAM", result.size())
                    // TODO: properly implement the sprite overflow bug
                    .sprite_overflow = true
                    break
                }
                let sprite_attr = .oam[sprite_addr + 2]
                let sprite_number = .oam[sprite_addr + 1]

                if .sprite_size_8x8 {
                    let vflip = (sprite_attr & 0x80) == 0x80
                    let tile_row = match vflip {
                        false => (scanline - sprite_y)
                        else => sprite_height - 1 - (scanline - sprite_y)
                    }
                    //let sprite_index = (tile_row & 0x7) | ((sprite_x & 0xf) << 4) | ((sprite_y & 0xf) << 8)
                    let sprite_index = .oam[sprite_addr + 1] as! u64 * 0x10 + tile_row as! u64
                    let first_plane = .chr_rom_byte_at(sprite_table, sprite_index)
                    let second_plane = .chr_rom_byte_at(sprite_table, sprite_index + 8)

                    mut mask = [0u8; 8]
                    for i in 0..8u8 {
                        mask[i] = ((first_plane >> i) & 0x1) | (((second_plane >> i & 0x1) << 1)) | ((sprite_attr & 0x3) << 2)
                    }

                    result.insert(before_index: 0, value: Sprite(
                        hflip: (sprite_attr & 0x40) == 0x40
                        mask: mask
                        bg_sprite: (sprite_attr & 0x20) == 0x20
                        sprite_x: sprite_x
                        sprite_zero: sprite == 0
                    ))
                    sprite_count += 1
                } else {
                    // 8x16
                    let vflip = (sprite_attr & 0x80) == 0x80
                    mut tile_row = match vflip {
                        false => (scanline - sprite_y)
                        else => sprite_height - 1 - (scanline - sprite_y)
                    }
                    //let sprite_index = (tile_row & 0x7) | ((sprite_x & 0xf) << 4) | ((sprite_y & 0xf) << 8)
                    mut sprite_index = (sprite_number >> 1) as! u64 * 0x20 + tile_row as! u64
                    if tile_row > 7 {
                        // bottom half of the sprite
                        tile_row -= 8
                        sprite_index += 8
                    }
                    let first_plane = .chr_rom_byte_at(sprite_table, sprite_index)
                    let second_plane = .chr_rom_byte_at(sprite_table, sprite_index + 8)

                    // sprite tile: 2
                    // 0000 + offset
                    // scanline: sprite_y (tile_row)
                    // 0x20 + 0
                    // sprite_table[0x20 + 0]
                    // sprite_table[0x20 + 8]

                    // sprite_table[0x21 + 0]
                    // sprite_table[0x21 + 8]

                    // sprite_table[0x27 + 0]
                    // sprite_table[0x27 + 8]

                    // sprite_table[0x30 + 0]
                    // sprite_table[0x30 + 8]

                    mut mask = [0u8; 8]
                    for i in 0..8u8 {
                        mask[i] = ((first_plane >> i) & 0x1) | (((second_plane >> i & 0x1) << 1)) | ((sprite_attr & 0x3) << 2)
                    }

                    result.insert(before_index: 0, value: Sprite(
                        hflip: (sprite_attr & 0x40) == 0x40
                        mask: mask
                        bg_sprite: (sprite_attr & 0x20) == 0x20
                        sprite_x: sprite_x
                        sprite_zero: sprite == 0
                    ))
                    sprite_count += 1
                }
            }
        }
        return result
    }


    function render_pixel(mut this) throws {
        // BACKGROUND
        //println("Hpx: {}, Vpx: {}", horizontal_pixel, vertical_pixel)
        let visible_row = (.vertical_pixel < 240) or (.vertical_pixel == 261)

        if .horizontal_pixel == 256 and visible_row and .rendering_enabled {
            .y_increment()
        }

        if .horizontal_pixel == 257 and visible_row and .rendering_enabled {
            let abcdef = .t & 0x41f
            .v = .v & 0x7be0
            .v = .v | abcdef
        }

        if (.horizontal_pixel >= 280) and (.horizontal_pixel <= 304) and (.vertical_pixel == 261) and .rendering_enabled {
            // GHIA.BC DEF.....
            let ghiabcdef = .t & 0x7be0
            .v = .v & 0x41f
            .v = .v | ghiabcdef
        }

        guard .horizontal_pixel < 256 else {
            return
        }

        guard .vertical_pixel < 240 else {
            return
        }

        // if .horizontal_pixel == 0 {
        //     .second_oam = .find_sprites(scanline: .vertical_pixel as! u8)  
        // }

        mut bg_pixel_set = false
        mut sprite_zero_set = false

        //if .sprites_visible {
        //    sprite_zero_set |= .render_sprite_pixel(horizontal_pixel, vertical_pixel, is_behind: true)
        //}

        // FIXME: when we add support for sprites remove this
        if .background_visible and (not .left_bg_mask or .horizontal_pixel >= 8) {
            bg_pixel_set = .render_bg_pixel()
        }

        if .sprites_visible and (not .left_sprite_mask or .horizontal_pixel >= 8) {
            .render_sprite_pixel(horizontal_pixel: .horizontal_pixel as! u8, vertical_pixel: .vertical_pixel as! u8, bg_set: bg_pixel_set)
        }

        if not .background_visible and not .sprites_visible {
            let rgb = .look_up_palette_entry_bg(palette_entry: 0)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb            
        }

        // if rgb.red != 0 and rgb.blue != 0 and rgb.green != 0 {
        //     println("{}, {} is {} {:0>2x}", horizontal_pixel, vertical_pixel, rgb, nametable_entry)
        // }
        // print("{:0>2x}", nametable_entry)
    }

    function look_up_palette_entry_bg(mut this, palette_entry: u8) -> u32 {
        guard palette_entry < 16 else {
            println("ERROR: incorrect palette entry: {}", palette_entry)
            //return RGB(red: 0, green: 0, blue: 0)
            abort()
        }

        let bg_palette = .palette[palette_entry as! u64]

        return .convert_palette_to_rgb(bg_palette)
    }

    function look_up_palette_entry_sprite(mut this, palette_entry: u8) -> u32 {
        guard palette_entry < 16 else {
            println("ERROR: incorrect palette entry: {}", palette_entry)
            //return RGB(red: 0, green: 0, blue: 0)
            abort()
        }

        match palette_entry {
            0 => { return .convert_palette_to_rgb(.palette[0x00]) }
            0x4 => { return .convert_palette_to_rgb(.palette[0x04]) }
            0x8 => { return .convert_palette_to_rgb(.palette[0x08]) }
            0xc => { return .convert_palette_to_rgb(.palette[0x0c]) }
            else => { return .convert_palette_to_rgb(.palette[0x10 + (palette_entry as! u64)]) }
        }
    }

    function ppu_ctrl(mut this, value: u8) {

        // 7  bit  0
        // ---- ----
        // VPHB SINN
        // |||| ||||
        // |||| ||++- Base nametable address
        // |||| ||    (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)
        // |||| |+--- VRAM address increment per CPU read/write of PPUDATA
        // |||| |     (0: add 1, going across; 1: add 32, going down)
        // |||| +---- Sprite pattern table address for 8x8 sprites
        // ||||       (0: $0000; 1: $1000; ignored in 8x16 mode)
        // |||+------ Background pattern table address (0: $0000; 1: $1000)
        // ||+------- Sprite size (0: 8x8 pixels; 1: 8x16 pixels â€“ see PPU OAM#Byte 1)
        // |+-------- PPU master/slave select
        // |          (0: read backdrop from EXT pins; 1: output color on EXT pins)
        // +--------- Generate an NMI at the start of the
        //            vertical blanking interval (0: off; 1: on)


        let gh = value & 0x3

        .t = .t & 0xf3ff
        .t = .t | ((gh as! u16) << 10)

        if (value & 0x4) == 0x4 {
            .vram_address_increment = 32
        } else {
            .vram_address_increment = 1
        }
        if (value & 0x8) == 0x8 {
            .sprite_table_address = 0x1000
        } else {
            .sprite_table_address = 0x0000
        }
        if (value & 0x10) == 0x10 {
            .background_table_address = 0x1000
        } else {
            .background_table_address = 0x0000
        }
        if (value & 0x20) == 0x20 {
            .sprite_size_8x8 = false
        } else {
            .sprite_size_8x8 = true
        }
        if (value & 0x80) == 0x80 {
            .nmi_on_vblank = true
        } else {
            .nmi_on_vblank = false
        }

        // println("base_table_address: {:0>4x} (vtick: {})", .base_table_address, .clock)
        // println("vram_address_increment: {}", .vram_address_increment)
        // println("sprite_table_address: {:0>4x}", .sprite_table_address)
        // println("background_table_address: {:0>4x}", .background_table_address)
        // println("sprite size 8x8: {}", .sprite_size_8x8)
        // println("nmi_on_vblank: {}", .nmi_on_vblank)
    }

    function ppu_mask(mut this, value: u8) {
        // TODO: implement

        // 7  bit  0
        // ---- ----
        // BGRs bMmG
        // |||| ||||
        // |||| |||+- Greyscale (0: normal color, 1: produce a greyscale display)
        // |||| ||+-- 1: Show background in leftmost 8 pixels of screen, 0: Hide
        // |||| |+--- 1: Show sprites in leftmost 8 pixels of screen, 0: Hide
        // |||| +---- 1: Show background
        // |||+------ 1: Show sprites
        // ||+------- Emphasize red (green on PAL/Dendy)
        // |+-------- Emphasize green (red on PAL/Dendy)
        // +--------- Emphasize blue

        let PPU_GREYSCALE_MASK = 0b00000001 as! u8
        let PPU_LEFT_BACKGROUND_MASK = 0b00000010 as! u8
        let PPU_LEFT_SPRITE_MASK = 0b00000100 as! u8
        let PPU_BACKGROUND_MASK = 0b00001000 as! u8
        let PPU_SPRITE_MASK = 0b00010000 as! u8
        let PPU_RED_EMPHASIZE_MASK = 0b00100000 as! u8
        let PPU_GREEN_EMPHASIZE_MASK = 0b01000000 as! u8
        let PPU_BLUE_EMPHASIZE_MASK = 0b10000000 as! u8

        // println("PPU mask: {:0>2x}", value)

        // TODO: Bool casts aren't working in Jakt, but the below should be a 
        // quick way to set a flag once they are
        //.sprites_visible = value << 6 >>> 7 as! bool
        if (value & PPU_SPRITE_MASK) == PPU_SPRITE_MASK {
            .sprites_visible = true
        } else {
            .sprites_visible = false
        }

        if (value & PPU_BACKGROUND_MASK) == PPU_BACKGROUND_MASK {
            .background_visible = true
        } else {
            .background_visible = false
        }

        if (value & PPU_LEFT_BACKGROUND_MASK) == PPU_LEFT_BACKGROUND_MASK {
            .left_bg_mask = false
        } else {
            .left_bg_mask = true
        }

        if (value & PPU_LEFT_SPRITE_MASK) == PPU_LEFT_SPRITE_MASK {
            .left_sprite_mask = false
        } else {
            .left_sprite_mask = true
        }

        let render_bytes = (value << 3) >>> 6
        if render_bytes == 0b00 {
            .rendering_enabled = false
        } else {
            .rendering_enabled = true
        }
    }

    function ppu_scroll(mut this, value: u8) {
        // println("PPU scroll: {:0>2x} {}", value, .scroll_toggle)

        if .w == 0 {
            let abcde = value >> 3
            .t = .t & 0xffe0
            .t = .t | abcde
            .x = value & 0x7
            .w = 1
        } else {
            let abcde = value >> 3
            let fgh = value & 0x7
            .t = .t & 0xc1f
            .t = .t | ((fgh as! u16) << 12)
            .t = .t | ((abcde as! u16) << 5)
            .w = 0
        }
    }

    function ppu_addr(mut this, value: u8) {
        if .w == 0 {
            let cdefgh = value & 0x3f
            .t = .t & 0xff
            .t = .t | ((cdefgh as! u16) << 8)
            .w = 1
        } else {
            .t = .t & 0xff00
            .t = .t | (value as! u16)
            .v = .t
            .w = 0
        }
    }

    function ppu_data_write(mut this, value: u8) {
        // TODO: add support for various mirroring

        // Outside of rendering, reads from or writes to $2007 will add either 1 or 32 to v depending on the VRAM increment bit set via $2000. 
        // During rendering (on the pre-render line and the visible lines 0-239, provided either background or sprite rendering is enabled), it 
        // will update v in an odd way, triggering a coarse X increment and a Y increment simultaneously (with normal wrapping behavior). 
        // Internally, this is caused by the carry inputs to various sections of v being set up for rendering, and the $2007 access triggering a 
        // "load next value" signal for all of v (when not rendering, the carry inputs are set up to linearly increment v by either 1 or 32). 
        // This behavior is not affected by the status of the increment bit. The Young Indiana Jones Chronicles uses this for some effects to 
        // adjust the Y scroll during rendering, and also Burai Fighter (U) to draw the scorebar. If the $2007 access happens to coincide with a 
        // standard VRAM address increment (either horizontal or vertical), it will presumably not double-increment the relevant counter.

        // Address range 	Size 	Description
        // $0000-$0FFF 	$1000 	Pattern table 0
        // $1000-$1FFF 	$1000 	Pattern table 1
        // $2000-$23FF 	$0400 	Nametable 0
        // $2400-$27FF 	$0400 	Nametable 1
        // $2800-$2BFF 	$0400 	Nametable 2
        // $2C00-$2FFF 	$0400 	Nametable 3
        // $3000-$3EFF 	$0F00 	Mirrors of $2000-$2EFF
        // $3F00-$3F1F 	$0020 	Palette RAM indexes
        // $3F20-$3FFF 	$00E0 	Mirrors of $3F00-$3F1F 

        // println("PPU data write rendering: {}, vblank: ", .rendering_enabled, .in_vblank)
        //  if .rendering_enabled or .in_vblank {

        mut address = .v & 0x3fff

        // println("PPU write: {:0>4x}", address)

        if address >= 0x4000 {
            println("bad ppu addr")
            abort()
        }

        if (address >= 0x0000) and (address <= 0x0fff) {
            .chr_rom_pages[.chr_rom_page_0000][address] = value
        }
        else if (address >= 0x1000) and (address <= 0x1fff) {
            .chr_rom_pages[.chr_rom_page_1000][address - 0x1000] = value            
        }
        else if (address >= 0x2000) and (address <= 0x2fff) {
            .write_nametable(address, value)
        }
        else if (address >= 0x3000) and (address <= 0x3eff) {
            // eprintln("Mirror of PPU nametable not yet supported")
            // abort()  
            .write_nametable(address: address - 0x1000, value)
        }
        else if (address >= 0x3f00) and (address <= 0x3fff) {
            let sub_address = (address - 0x3f00) % 0x20
            // FIXME: add back in mirroring
            .palette[sub_address] = value & 0x3f
        }
        match address {
            0x3f00 => { .palette[0x10] = value }
            0x3f04 => { .palette[0x14] = value }
            0x3f08 => { .palette[0x18] = value }
            0x3f0C => { .palette[0x1C] = value }
            0x3f10 => { .palette[0x00] = value }
            0x3f14 => { .palette[0x04] = value }
            0x3f18 => { .palette[0x08] = value }
            0x3f1C => { .palette[0x0C] = value }
            else => {}
        }
        .increment_v()
    }

    function increment_v(mut this) {
        if (.background_visible or .sprites_visible) and (.vertical_pixel < 240 or .vertical_pixel == 261) {
            .coarse_x_increment()
            .y_increment()
        } else {
            .v += .vram_address_increment
        }
    }

    function ppu_data_read(mut this) -> u8 {
        mut output = 0u8
        // println("PPU read: {:0>4x}", .v)

        let address = .v & 0x3fff

        if address <= 0x3eff {
            mut value: u8 = 0
            if address < 0x1000 {
                value = .chr_rom_byte_at(.chr_rom_page_0000, address as! u64)
            } else if address < 0x2000 {
                value = .chr_rom_byte_at(.chr_rom_page_1000, address as! u64 - 0x1000)
            } else if (address >= 0x2000) and (address <= 0x2fff){
                value = .read_nametable(address)
            }
            .increment_v()
            output = .buffered_read
            .buffered_read = value
        } else {
            let value = .palette[address - 0x3f00]
            .increment_v()
            output = value
        }
        return output
    }

    function ppu_status(mut this) -> u8 {
        mut status = 0
        if .in_vblank {
            // println("Reading vblank status")
            status |= 0x80
        }
        if .sprite_zero_hit {
            status |= 0x40
        }

        .w = 0
        if (.vertical_pixel == 241) and (.horizontal_pixel >= 1 or .horizontal_pixel <= 3){
            .dont_vblank = true
        }
        .in_vblank = false
        return status
    }

    public function write_ppu_addr(mut this, address: u16, value: u8) {
        // PPU registers are mirrored all the way to 3FFF, try to handle that
        let mirrored_address = (address % 0x8) + 0x2000
        match mirrored_address {
            0x2000 => .ppu_ctrl(value)
            0x2001 => .ppu_mask(value)
            0x2003 => .oam_addr_write(value) //From NESDEV wiki - most games write $00 here and use OAMDMA
            0x2004 => .oam_data_write(value)
            0x2005 => .ppu_scroll(value) // Write twice
            0x2006 => .ppu_addr(value) // Write twice
            0x2007 => .ppu_data_write(value)
            else => {
                eprintln("Unimplemented write to: {:0>4x}", mirrored_address)
                abort()
            }
        }
    }

    public function oam_addr_write(mut this, value: u8) {
        .oam_addr = value
    }

    public function oam_data_read(mut this) -> u8 {
        let result = .oam[.oam_addr]
        .oam_addr++
        return result
    }

    public function oam_data_write(mut this, value: u8) {
        .oam[.oam_addr] = value
        .oam_addr++
    }

    public function read_ppu_addr(mut this, address: u16) -> u8 {
        let mirrored_address = (address % 0x8) + 0x2000
        return match mirrored_address {
            0x2002 => .ppu_status()
            0x2004 => .oam_data_read()
            0x2007 => .ppu_data_read()
            else => {
                eprintln("Unimplemented read from: {:0>4x}", mirrored_address)
                abort()
            }
        }
    }

    function convert_palette_to_rgb(this, anon value: u8) -> u32 {
        return .color_palette[value & 0x3f]
    }

}

function rgb(anon red: u8, anon green: u8, anon blue: u8) -> u32 {
    return (255 << 24) | (blue << 16) | (green << 8) | red 
}
