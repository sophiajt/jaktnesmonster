class RGB {
    public red: u8
    public green: u8
    public blue: u8
}

class PPU {
    // base_table_address: u16
    vram_address_increment: u16
    sprite_table_address: u16
    background_table_address: u16
    sprite_size_8x8: bool
    public nmi_on_vblank: bool
    clock: u64
    public in_vblank: bool
    vram: [u8]
    // public vram_rw_addr: u16
    public oam: [u8]
    vram_page_0000: [u8]
    vram_page_1000: [u8]
    public video_buffer: [RGB]
    // scroll_x: u8
    // scroll_y: u8
    // scroll_toggle: bool
    background_visible: bool
    sprites_visible: bool
    buffered_read: u8
    sprite_zero_hit: bool
    public debug: bool

    // Internal PPU registers (from https://www.nesdev.org/wiki/PPU_scrolling)
    v: u16
    t: u16
    x: u8
    w: u8

    public function init(vram_page_0000: [u8], vram_page_1000: [u8]) throws -> PPU {
        mut video_buffer: [RGB] = []
        for _ in 0..(256*240) {
            video_buffer.push(rgb(0, 0, 0))
        }
        return PPU(
            vram_address_increment: 1
            sprite_table_address: 0x0000
            background_table_address: 0x0000
            sprite_size_8x8: true
            nmi_on_vblank: false
            clock: 0
            in_vblank: false
            vram: [0; 0x2000]
            oam: [0; 256]
            vram_page_0000
            vram_page_1000
            video_buffer
            background_visible: false
            sprites_visible: false
            buffered_read: 0
            sprite_zero_hit: false
            debug: false

            // internal PPU registers
            v: 0
            t: 0
            x: 0
            w: 0
        )
    }

    public function tick(mut this, cycles: u64) throws {
        for x in (.clock)..(.clock + cycles) {
            .render_pixel()
            .clock += 1

            if .clock == (341u64 * 241u64 + 1) {
                .in_vblank = true
            } else if .clock == (341u64 * 261u64) {
                .in_vblank = false
                .sprite_zero_hit = false
            } else if .clock == (341u64 * 262u64) {
                .clock = 0
            }
        }
    }

    function read_vram(this, anon addr: u16) -> u8 {
        return .vram[addr]
    }

    function render_bg_pixel(mut this, horizontal_pixel: u64, vertical_pixel: u64) throws -> bool {
        let scroll_x = (.v & 0x1f) * 8 + .x as! u16
        let scroll_y = ((.v >> 5) & 0x1f) * 8 + (.v >> 12)

        mut virtual_horizontal_pixel = horizontal_pixel + scroll_x as! u64
        mut virtual_vertical_pixel = vertical_pixel + scroll_y as! u64

        let base_table_select = (.v >> 10) & 0x3

        mut base_table_address: u16 = match base_table_select {
            0 => 0x2000
            1 => 0x2400
            2 => 0x2800
            3 => 0x2c00
            else => {abort()}
        }

        if virtual_horizontal_pixel >= 256 {
            // FIXME: we're assuming vertical mirroring
            base_table_address ^= 0x400
            virtual_horizontal_pixel -= 256
        }

        if virtual_vertical_pixel >= 240 {
            base_table_address ^= 0x800
            virtual_vertical_pixel -= 240
        }

        // Which tile
        let vertical_tile: u16 = virtual_vertical_pixel / 8
        let horizontal_tile: u16 = virtual_horizontal_pixel / 8

        // Fetch nametable entry
        let nametable_entry = .read_vram(base_table_address - 0x2000 + vertical_tile * 32 + horizontal_tile)
        // let nametable_entry = .vram[.base_table_address - 0x2000 + vertical_tile * 32 + horizontal_tile]
        
        let vertical_attr = vertical_tile / 4
        let horizontal_attr = horizontal_tile / 4

        // 0000
        // ^^^^  
        // | ||
        // | | plane 0
        // | plane 1
        // attr (2 bits)

        let attr = .read_vram(base_table_address - 0x2000 + 0x3c0 + vertical_attr * 8 + horizontal_attr) // subtract 0x2000 because of chr rom

        let horizontal_box_pos = (horizontal_tile % 4) / 2
        let vertical_box_pos = (vertical_tile % 4) / 2

        let color_bits = (attr >> ((horizontal_box_pos * 2) + (vertical_box_pos * 4))) & 0x3

        let first_plane_byte = match .background_table_address {
            0000 => .vram_page_0000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8]
            else => .vram_page_1000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8]
        }
        let second_plane_byte = match .background_table_address {
            0000 => .vram_page_0000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8 + 8]
            else => .vram_page_1000[nametable_entry as! u64 * 0x10 + virtual_vertical_pixel % 8 + 8]
        }

        let first_plane_bit = first_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1
        let second_plane_bit = second_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1

        let palette_entry = first_plane_bit + (second_plane_bit * 2) + (color_bits * 4)

        if (first_plane_bit == 0) and (second_plane_bit == 0) {
            let rgb = .look_up_palette_entry_bg(palette_entry: 0)
            .video_buffer[vertical_pixel * 256 + horizontal_pixel] = rgb
            return false
        } else {
            let rgb = .look_up_palette_entry_bg(palette_entry)
            .video_buffer[vertical_pixel * 256 + horizontal_pixel] = rgb
            return true
        }
    }

    function render_sprite_pixel(mut this, horizontal_pixel: u64, vertical_pixel: u64, is_behind: bool) throws -> bool {
        for sprite in 63..-1 {
            let sprite_attr = .oam[sprite * 4 + 2]

            if (sprite_attr & 0x20) == 0x20 and not is_behind {
                continue
            }

            if (sprite_attr & 0x20) == 0x0 and is_behind {
                continue
            }

            let sprite_y = .oam[sprite * 4] as! u64

            let sprite_x = .oam[sprite * 4 + 3] as! u64

            let sprite_y = .oam[sprite * 4] as! u64

            let sprite_x = .oam[sprite * 4 + 3] as! u64

            // TODO: handle 8x16 sprites
            if (vertical_pixel >= sprite_y) and (vertical_pixel < (sprite_y + 8)) and (horizontal_pixel >= sprite_x) and (horizontal_pixel < (sprite_x + 8)) {
                mut sprite_row = (vertical_pixel - sprite_y) as! u64
                mut sprite_col = (horizontal_pixel - sprite_x) as! u64
                                
                let sprite_index = .oam[sprite * 4 + 1]

                let sprite_index = .oam[sprite * 4 + 1]

                if (sprite_attr & 0x80) == 0x80 {
                    sprite_row = 7 - sprite_row
                }

                if (sprite_attr & 0x40) == 0x40 {
                    sprite_col = 7 - sprite_col
                }

                let first_plane_byte = match .sprite_table_address {
                    0000 => .vram_page_0000[sprite_index as! u64 * 0x10 + sprite_row]
                    else => .vram_page_1000[sprite_index as! u64 * 0x10 + sprite_row]
                }
                let second_plane_byte = match .sprite_table_address {
                    0000 => .vram_page_0000[sprite_index as! u64 * 0x10 + sprite_row + 8]
                    else => .vram_page_1000[sprite_index as! u64 * 0x10 + sprite_row + 8]
                }

                let first_plane_bit = first_plane_byte >> (7 - sprite_col) & 0x1
                let second_plane_bit = second_plane_byte >> (7 - sprite_col) & 0x1

                let color_bits = sprite_attr & 0x3

                let palette_entry = first_plane_bit + (second_plane_bit * 2) + (color_bits * 4)

                if (first_plane_bit == 0) and (second_plane_bit == 0) {
                    if is_behind {
                        let rgb = .look_up_palette_entry_sprite(palette_entry: 0)
                        .video_buffer[vertical_pixel * 256 + horizontal_pixel] = rgb
                    }
                } else {
                    let rgb = .look_up_palette_entry_sprite(palette_entry)
                    .video_buffer[vertical_pixel * 256 + horizontal_pixel] = rgb

                    if not .sprite_zero_hit and sprite == 0 {
                        return true
                    }
                }
            }
        }

        return false
    }

    function coarse_x_increment(mut this) {
        // if ((v & 0x001F) == 31) // if coarse X == 31
        //     v &= ~0x001F          // coarse X = 0
        //     v ^= 0x0400           // switch horizontal nametable
        // else
        //     v += 1                // increment coarse X

        if (.v & 0x001f) == 31 {
            .v &= ~0x001fu16
            .v ^= 0x400
        } else {
            .v += 1
        }
    }

    function y_increment(mut this) {
        // if ((v & 0x7000) != 0x7000)        // if fine Y < 7
        //   v += 0x1000                      // increment fine Y
        // else
        //   v &= ~0x7000                     // fine Y = 0
        //   int y = (v & 0x03E0) >> 5        // let y = coarse Y
        //   if (y == 29)
        //     y = 0                          // coarse Y = 0
        //     v ^= 0x0800                    // switch vertical nametable
        //   else if (y == 31)
        //     y = 0                          // coarse Y = 0, nametable not switched
        //   else
        //     y += 1                         // increment coarse Y
        //   v = (v & ~0x03E0) | (y << 5)     // put coarse Y back into v

        if (.v & 0x7000) != 0x7000 {
            .v += 0x1000
        } else {
            .v &= ~0x7000u16
            mut y = (.v & 0x3e0) >> 5
            if y == 29 {
                y = 0
                .v ^= 0x800
            } else if y == 31 {
                y = 0
            } else {
                y += 1
            }
            .v = (.v & ~0x03e0u16) | (y << 5)
        }
    }
    function render_pixel(mut this) throws {
        // BACKGROUND

        // Where are we on the screen
        let horizontal_pixel = .clock % 341
        let vertical_pixel = .clock / 341

        if horizontal_pixel == 256 and .background_visible {
            .y_increment()
        }

        if horizontal_pixel == 257 and .background_visible {
            let abcdef = .t & 0x41f
            .v = .v & 0xbe0
            .v = .v | abcdef
        }

        if (horizontal_pixel >= 280) and (horizontal_pixel <= 304) and (vertical_pixel == 262) and .background_visible {
            // GHIA.BC DEF.....
            let ghiabcdef = .t & 0x7be0
            .v = .v & 0x41f
            .v = .v | ghiabcdef
        }

        guard horizontal_pixel < 256 else {
            return
        }

        guard vertical_pixel < 240 else {
            return
        }

        mut bg_pixel_set = false
        mut sprite_zero_set = false

        if .sprites_visible {
            sprite_zero_set |= .render_sprite_pixel(horizontal_pixel, vertical_pixel, is_behind: true)
        }

        // FIXME: when we add support for sprites remove this
        if .background_visible {
            bg_pixel_set = .render_bg_pixel(horizontal_pixel, vertical_pixel)
        }

        if .sprites_visible {
            sprite_zero_set |= .render_sprite_pixel(horizontal_pixel, vertical_pixel, is_behind: false)
        }

        if bg_pixel_set and sprite_zero_set {
            .sprite_zero_hit = true
        }

        // if rgb.red != 0 and rgb.blue != 0 and rgb.green != 0 {
        //     println("{}, {} is {} {:0>2x}", horizontal_pixel, vertical_pixel, rgb, nametable_entry)
        // }
        // print("{:0>2x}", nametable_entry)
    }

    function look_up_palette_entry_bg(mut this, palette_entry: u8) throws -> RGB {
        guard palette_entry < 16 else {
            println(format("ERROR: incorrect palette entry: {}", palette_entry))
            return RGB(red: 0, green: 0, blue: 0)
        }

        let bg_palette = .vram[0x1f00 + palette_entry as! u64]

        return convert_palette_to_rgb(bg_palette)
    }

    function look_up_palette_entry_sprite(mut this, palette_entry: u8) throws -> RGB {
        guard palette_entry < 16 else {
            println(format("ERROR: incorrect palette entry: {}", palette_entry))
            return RGB(red: 0, green: 0, blue: 0)
        }

        if palette_entry == 0 {
            let sprite_palette = .vram[0x1f00]
            return convert_palette_to_rgb(sprite_palette)
        } else if palette_entry == 0x4 {
            let sprite_palette = .vram[0x1f04]
            return convert_palette_to_rgb(sprite_palette)
        } else if palette_entry == 0x8 {
            let sprite_palette = .vram[0x1f08]
            return convert_palette_to_rgb(sprite_palette)
        } else if palette_entry == 0xc {
            let sprite_palette = .vram[0x1f0c]
            return convert_palette_to_rgb(sprite_palette)
        } else {
            let sprite_palette = .vram[0x1f10 + palette_entry as! u64]
            return convert_palette_to_rgb(sprite_palette)
        }
    }

    function ppu_ctrl(mut this, value: u8) {
        let gh = value & 0x3

        .t = .t & 0xf3ff
        .t = .t | ((gh as! u16) << 10)

        if (value & 0x4) == 0x4 {
            .vram_address_increment = 32
        } else {
            .vram_address_increment = 1
        }
        if (value & 0x8) == 0x8 {
            .sprite_table_address = 0x1000
        } else {
            .sprite_table_address = 0x0000
        }
        if (value & 0x10) == 0x10 {
            .background_table_address = 0x1000
        } else {
            .background_table_address = 0x0000
        }
        if (value & 0x20) == 0x20 {
            .sprite_size_8x8 = false
        } else {
            .sprite_size_8x8 = true
        }
        if (value & 0x80) == 0x80 {
            .nmi_on_vblank = true
        } else {
            .nmi_on_vblank = false
        }

        // println("base_table_address: {:0>4x} (vtick: {})", .base_table_address, .clock)
        // println("vram_address_increment: {}", .vram_address_increment)
        // println("sprite_table_address: {:0>4x}", .sprite_table_address)
        // println("background_table_address: {:0>4x}", .background_table_address)
        // println("sprite size 8x8: {}", .sprite_size_8x8)
        // println("nmi_on_vblank: {}", .nmi_on_vblank)
    }

    function ppu_mask(mut this, value: u8) {
        // TODO: implement
        // println("PPU mask: {:0>2x}", value)
        if (value & 0x10) == 0x10 {
            .sprites_visible = true
        } else {
            .sprites_visible = false
        }

        if (value & 0x8) == 0x8 {
            .background_visible = true
        } else {
            .background_visible = false
        }
    }

    function ppu_scroll(mut this, value: u8) {
        // println("PPU scroll: {:0>2x} {}", value, .scroll_toggle)

        if .w == 0 {
            let abcde = value >> 3
            .t = .t & 0xffe0
            .t = .t | abcde
            .x = value & 0x7
            .w = 1
        } else {
            let abcde = value >> 3
            let fgh = value & 0x7
            .t = .t & 0xc1f
            .t = .t | ((fgh as! u16) << 12)
            .t = .t | ((abcde as! u16) << 5)
            .w = 0
        }
    }

    function ppu_addr(mut this, value: u8) {
        if .w == 0 {
            let cdefgh = value & 0x3f
            .t = .t & 0xff
            .t = .t | ((cdefgh as! u16) << 8)
            .w = 1
        } else {
            .t = .t & 0xff00
            .t = .t | (value as! u16)
            .v = .t
            .w = 0
        }
    }

    function ppu_data_write(mut this, value: u8) {
        // TODO: add support for various mirroring
        if .v >= 0x4000 {
            println("bad ppu addr")
            abort()
        }

        if .v == 0x3f10 {
            .vram[0x1f00] = value
        } else if .v == 0x3f14 {
            .vram[0x1f04] = value
        } else if .v == 0x3f18 {
            .vram[0x1f08] = value
        } else if .v == 0x3f1c {
            .vram[0x1f0c] = value
        } else {
            .vram[.v - 0x2000] = value
        }
        .v += .vram_address_increment
    }

    function ppu_data_read(mut this) -> u8 {
        mut output = 0u8
        if .v <= 0x3eff {
            if .v < 0x1000 {
                let value = .vram_page_0000[.v]
                .v += .vram_address_increment
                
                output = .buffered_read
                .buffered_read = value
            } else if .v < 0x2000 {
                let value = .vram_page_1000[.v - 0x1000]
                .v += .vram_address_increment

                output = .buffered_read
                .buffered_read = value
            } else {
                let value = .vram[.v - 0x2000]
                .v += .vram_address_increment

                output = .buffered_read
                .buffered_read = value
            }
        } else {
            let value = .vram[.v - 0x2000]
            .v += .vram_address_increment

            output = value
        }

        return output
    }

    function ppu_status(mut this) -> u8 {
        mut status = 0
        if .in_vblank {
            // println("Reading vblank status")
            status |= 0x80
        }
        if .sprite_zero_hit {
            status |= 0x40
        }

        .w = 0

        .in_vblank = false
        return status
    }

    public function write_ppu_addr(mut this, address: u16, value: u8) {
        match address {
            0x2000 => .ppu_ctrl(value)
            0x2001 => .ppu_mask(value)
            0x2005 => .ppu_scroll(value)
            0x2006 => .ppu_addr(value)
            0x2007 => .ppu_data_write(value)
            else => {}
        }
    }

    public function read_ppu_addr(mut this, address: u16) -> u8 {
        return match address {
            0x2002 => .ppu_status()
            0x2007 => .ppu_data_read()
            else => 0
        }
    }
}

function rgb(anon red: u8, anon green: u8, anon blue: u8) throws -> RGB {
    return RGB(red, green, blue)
}

function convert_palette_to_rgb(anon value: u8) throws -> RGB {
    return match value {
        0x00 => rgb(101 101 101)
        0x01 => rgb(0    45 105)
        0x02 => rgb(19   31 127)
        0x03 => rgb(69   19 124)
        0x04 => rgb(96   11  98)
        0x05 => rgb(115  10  55)
        0x06 => rgb(113  15   7)
        0x07 => rgb(90   26   0)
        0x08 => rgb(52   40   0)
        0x09 => rgb(11   52   0)
        0x0a => rgb(0   60    0)    
        0x0b => rgb(0   61   16)    
        0x0c => rgb(0   56   64)
        0x0d => rgb(0    0    0)
        0x0e => rgb(0    0    0)
        0x0f => rgb(0    0    0)
        0x10 => rgb(174 174 174)
        0x11 => rgb(15   99 179)
        0x12 => rgb(64   81 208)
        0x13 => rgb(120  65 204)
        0x14 => rgb(167  54 169)
        0x15 => rgb(192  52 112)
        0x16 => rgb(189  60  48)
        0x17 => rgb(159  74   0)
        0x18 => rgb(109  92   0)
        0x19 => rgb(54  109   0)
        0x1a => rgb(7   119   4)
        0x1b => rgb(0   121  61)
        0x1c => rgb(0   114 125)
        0x1d => rgb(0     0   0)
        0x1e => rgb(0     0   0)
        0x1f => rgb(0     0   0)
        0x20 => rgb(254 254 255)
        0x21 => rgb(93  179 255)
        0x22 => rgb(143 161 255)
        0x23 => rgb(200 144 255)
        0x24 => rgb(247 133 250)
        0x25 => rgb(255 131 192)
        0x26 => rgb(255 139 127)
        0x27 => rgb(239 154  73)
        0x28 => rgb(189 172  44)
        0x29 => rgb(133 188  47)
        0x2a => rgb(85  199  83)    
        0x2b => rgb(60  201 140)    
        0x2c => rgb(62  194 205)
        0x2d => rgb(78   78  78)
        0x2e => rgb(0     0   0)
        0x2f => rgb(0     0   0)
        0x30 => rgb(254 254 255)
        0x31 => rgb(188 223 255)
        0x32 => rgb(209 216 255)
        0x33 => rgb(232 209 255)
        0x34 => rgb(251 205 253)
        0x35 => rgb(255 204 229)
        0x36 => rgb(255 207 202)
        0x37 => rgb(248 213 180)
        0x38 => rgb(228 220 168)
        0x39 => rgb(204 227 169)
        0x3a => rgb(185 232 184)    
        0x3b => rgb(174 232 208)    
        0x3c => rgb(175 229 234)
        0x3d => rgb(182 182 182)
        0x3e => rgb(0    0    0)
        0x3f => rgb(0    0    0)
        else => {
            println("ERROR: incorrect palette for rgb")
            yield rgb(0, 0, 0)
        }
    }
}